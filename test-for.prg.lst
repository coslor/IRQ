   1                   .include "for-macros.asm"
   1                   .include "macros.asm"
   1                   .ifndef constants
   2                   .include "const.asm"
   1                   constants=1			
   2                   
   3                   ;
   4                   ; utility routines
   5                   ;
   6                   CLR_SCREEN = $e544
   7                   PLOTK = $e50a			; read/set cursor row(x), col(y) 
   8                   SCROL = $e8ea			; scroll the screen up 1 line 
   9                   DSPP = $ea31			; read the screen & put char in A, color in X 
  10                   MOVE_UP = $a3bf			; move a block of memory up, or move memory  
  11                   						;	from one non-overlapping region to another.
  12                   						;	$5f-$60=source block starting address
  13                   						;	$5a-5b=source block ending address +1
  14                   						;	$58-59=destination's ending address +1
  15                   
  16                   
  17                   ;
  18                   ;	I/O ROUTINES
  19                   ;
  20                   CHROUT = $FFD2			; write byte to default output
  21                   CHRIN = $FFCF			; read byte from default input
  22                   
  23                   SETLFS = $FFBA			; set logical file numbers (open a,x,y)
  24                   SETNAM = $FFBD			; set file name(a=len,x/y=lo/hi for pointer)
  25                   OPEN = $FFC0			; open file (out:c=err, a=1,2,4,5,8 error code)
  26                   CLOSE = $FFC3			; close file (a=fileno)
  27                   CHKIN = $FFC6			; set file as default input(a=filenumber,C=error)
  28                   CHKOUT = $FFC9			; set file as default output(a=filenumber,C=error)
  29                   CLRCHN = $FFCC			; close default input/output files
  30                   LOAD = $FFD5
  31                   SAVE = $FFD8
  32                   GETIN = $FFE4			; read byte from default input (diff with CHRIN?)
  33                   CLALL = $FFE7			; clear file table & call CLRCHN
  34                   READST = $ffb7			; read STatus, leaves it in A
  35                   STATUS = $90			; ST for serial devices.						
  36                   						;	For serial devices:						
  37                   						;		bit 0:timeout (write)
  38                   						;		bit 1:timeout (read)
  39                   						;		bit 6:EOF
  40                   						;		bit 7:device not present 						
  41                   
  42                   STROUT = $ab1e			; print zt string,addr in A/Y
  43                   LINPRT = $BDCD			; print UNSIGNED int in A/X 
  44                   
  45                   PRTSPC = $ab4d			; print a space character
  46                   CRDO = $aad7			; print a CR character, followed by LF
  47                   						;	if channel > 128
  48                   						
  49                   STOP = $ffe1			; check for STOP key. If pressed, 
  50                   						; 	set Z (BEQ), call CLRCHN, print "break".
  51                   FTXTPTR = $7a			; pointer into (usually BASIC) text						
  52                   
  53                   ;
  54                   ;	FAC MATH
  55                   ;
  56                   MOVFA = $bbfc			; copy FAC2 to FAC1
  57                   						
  58                   FAC1 = $61				; $61:exponent (power of 2). 128 or greater means 
  59                   						;	negative exponent
  60                   						; $62-65:mantissa. Also, $62-63 hold result of
  61                   						;	FAC1-to-int conversions
  62                   						; $66:sign. 0=positive, $ff=negative
  63                   						
  64                   FAC2 = $69				; same structure as FAC1
  65                   
  66                   
  67                   AADD = $bd7e			; add A to FAC1
  68                   
  69                   ADDH = $b849			; add 0.5 to FAC1 for rounding
  70                   FSUBT = $b853			; FAC1=FAC2 - FAC1
  71                   FADDT = $b86f			; FAC1=FAC@ + FAC1
  72                   NEGFAC = $b947			; FAC1=negative (2's complement) of FAC1
  73                   FMULTT = $ba30			; FAC1=FAC1 * FAC2
  74                   FDIVT = $bb14			; FAC1=FAC2 / FAC1
  75                   ROUND = $bc2b			; FAC1 = ROUND(FAC1)
  76                   SIGN = $bc2b			; A=(0 if FAC1=0, 1 if FAC1>0, $FF(-1) otherwise)
  77                   						
  78                   FOUTIM = $be68			; convert TI to ASCII string at $100 
  79                   SQR = $bf71				; FAC1=SQR(FAC1) 
  80                   FPWRT = $bf78			; FAC1=FAC2^FAC1 
  81                   NEGOP = $bfb4			; FAC1 = NOT(FAC1) 
  82                   EXP = $bfed				; FAC1=e^EXP1 
  83                   RND = $e097				; FAC1=RND(FAC1), using BASIC's RND() logic 
  84                   COS = $e264				; FAC1=COS(FAC1) 
  85                   SIN = $e26b				; FAC1=SIN(FAC1) 
  86                   TAN = $e2b4				; FAC1=TAN(FAC1) 
  87                   ATN = $e30e				; FAC1=ATAN(FAC1) 
  88                   EVAL = $ae83			; evaluate an arithmetic term from ASCII  
  89                   						;	to a floating point value.   
  90                   
  91                   ;
  92                   ;	FAC CONVERSION ROUTINES
  93                   ;
  94                   PETSCII_TO_FAC1=$bcf3	; convert a PETSCII string containing 
  95                   						; 	a FP constant, to FAC1. before calling,  
  96                   						; 	store the address of the string in $7a/7b, 
  97                   						; 	then JSR $79.
  98                   						
  99                   STRVAL = $b7b5			; convert PETSCII-string to FAC1. Expects 
 100                   						;   string-address in $22/$23 and 
 101                   						;	length of string in accumulator.
 102                   						
 103                   GIVAYF = $b391			; convert signed int in Y/A to FAC1; range -32768 to 32767
 104                   FACINX = $B1AA			; convert FAC1 to 2-byte signed int in A/Y
 105                   FIN = $bfc3				; convert string (pointed to by TXTPTR) 
 106                   						;	to float in FAC1
 107                   FOUT = $bddd			; convert FAC1 to ASCII string, starting at $100
 108                   						; 	and ending with a 0 term. On exit, A/Y holds
 109                   						; 	start address, so STROUT can be called.
 110                   A_TO_FAC1 = $bc3c		; convert unsigned 8-bit int in A to FAC1						
 111                   SNGET = $b3a2  			; convert unsigned 8-bit int in Y to FAC1 
 112                   QINT = $bc9b			; convert FAC1 into 4-byte signed int from $62-65 
 113                   GETADR = $b7f7			; convert FAC1 to a 16-bit int, in $14/$15						
 114                    
 115                    
 116                   ;
 117                   ; interrupt vectors
 118                   ;
 119                   CVINV = $314			; point to IRQ handler, normally $ea31.
 120                   						;	NOTE: A,X,Y are saved on the stack before calling,
 121                   						;		but they are NOT automatically restored
 122                   						
 123                   CBINV = $316			; BRK interrupt handler. Normally $fe66.  
 124                   NMINV = $318			; NMI handler, normally $fe47.  
 125                   						;	NOTE: to disable RS/RESTORE, store a 0 in $318.
 126                   						
 127                   
 128                   						  						 
 129                   
 130                   ;
 131                   ; passing data between basic and ml
 132                   ;
 133                   
 134                   
 135                   A_STORAGE = $30c		; the registers are read from these 
 136                   X_STORAGE = $30d 		;	locations before running a SYS routine,
 137                   Y_STORAGE = $30e 		; 	and the results are stored back into 
 138                   P_STORAGE = $30f 		;	them after the RTS. doesn't apply to USR.
 139                   
 140                   USERADD = $311			; the 16-bit address of a USR routine can be 
 141                   						; 	put into this vector. for example:
 142                   						;		x=usr(17) 								
 143                   						;	...puts the value of 17 in FAC1, calls
 144                   						; 	the routine in $311-312, and assigns the
 145                   						;	value of FAC1 upon exiting, to the var x.
 146                   ;
 147                   ; other basic stuff
 148                   ;
 149                   CHRGET = $73			; reads the next character for processing by basic.
 150                   						;	sets P to indicate what kind of char,  
 151                   						; 	and returns the char in A. C=0-9,Z=end of stmt.
 152                   						
 153                   CHRGOT = $79			; does the same thing, but doesn't increment the						
 154                   						;	char pointer.						
 155                   												
 156                   VERCK = $A				; flag:0=LOAD,1=VERIFY												
 157                   VALTYP = $D				; flag:$FF=string,0=numeric							
 158                   INTFLG = $E				; flag:$80=int,0=fp												
 159                   INPFLG = $11			; flag:0=INPUT,$40=GET,$98=READ												
 160                   CHANNL = $13			; current logical file number (not dev#)												
 161                   TXTTAB = $2b			; beginning of BASIC text, normally $801 
 162                   MEMSIZ = $37			; end of BASIC-available memory 
 163                   CURLIN = $39			; current BASIC line#. $ff in $40 means immediate mode 
 164                   VARPNT = $47			; descriptor of current BASIC variable value 
 165                   OPMASK = $4D			; comparison operation flag: 1=<,2=> 
 166                   DSCPNT = $50			; $50-51 point to current string descriptor, 
 167                   						; 	$52 holds string length
 168                   						
 169                   ARISGN = $6f			; result of comparison between FAC1,FAC2						
 170                   						;	0=like signs, $ff=unlike signs						
 171                   
 172                   STKEY = $91				; value of the last row of the keybd when last scanned. 												 
 173                   						;	$ff=none,$fe=1,$fd=<-,$fb=CTRL,$ef=SPACE,
 174                   						;	$df=Commodore,$bf=Q,$7f=STOP.
 175                   						;	NOTE: this means that you can do this:
 176                   						;		LDA STKEY
 177                   						;		BPL handle_stop
 178                   						
 179                   VERCK2 = $93				; flag for load routine: 0=load/1=verify												
 180                   DFLTN = $99				; current default input device
 181                   DFLTO = $9A				; current default output device
 182                   TIME = $A0				; software jiffy clock, from $a0-a2. 
 183                   						;	24-bit count of jiffies (60/sec) since start.
 184                   						;	resets every 24 hours.
 185                   
 186                   FNLEN = $b7				; size of current filename						
 187                   LA = $b8				; current logical file number(for a different						
 188                   						;	purpose then $13)						
 189                   SA = $b9				; current secondary address												
 190                   FA = $ba				; current device number												
 191                   FNADR = $BB				; 2-byte pointer to filename												
 192                   LSTX = $c5				; matrix coordinate of *last* keypress; 64=none												
 193                   NDX = $c6				; # of characters in keyboard buffer												
 194                   RVS = $c7				; flag: print reverse characters? 0=no												
 195                   						;	NOTE: you can poke 0 here to cancel reverse mode												
 196                   SFDX = $cb				; matrix coords of *current* keypress; 64=none
 197                   BLNSW = $cc				; cursor blink enable:0=flash
 198                   GDBLN = $ce				; screen code of char under cursor
 199                   PNTR = $d3				; cursor column on current line
 200                   QTSW = $d4				; editor in quote mode? 0=no
 201                   TBLx = $d6				; current cursor physical line #
 202                   INSRT = $d8				; insert mode? >0 is # of inserts
 203                   USER = $f3				; 2-byte pointer to current screen color location
 204                   
 205                   COLOR = $286			; current foreground color for text
 206                   GDCOL = $287			; color of character under cursor
 207                   HIBASE = $288			; page of screen memory; normally contains 4(*256=1024)
 208                   						;	NOTE: $d018/$dd00 change ths *display*
 209                   						;	screen location - the one that shown onscreen.
 210                   						; 	this one is the memory written into by CHROUT,etc.
 211                   						
 212                   XMAX	= $289			; max keyvoard buffer size; should be <=10						
 213                   RPTFLAG = $28a			; flag: which keys should repeat?						
 214                   						;	0=normal,$80=all,$40=none						
 215                   												
 216                   SHFLAG = $653			; flag: modifier keys currently pressed?											
 217                   						;	bits: 1=SHIFT,2=Commodore,4=CTRL											
 218                   																	
 219                   MODE = $291				; flag: enable changing char sets with SHIFT/C= ?																	
 220                   						;	$80=disabled, 0=enabled																	
 221                   																							
 222                   AUTODN = $292			; flag: scroll screen on col 40/last line?																							
 223                   						;	0=yes; otherwise=no																							
 224                   																													
 225                   																													
 226                   																		 
 227                   BUF = $200				; BASIC line editor input buffer 
 228                    
 229                    												
 230                   ;
 231                   ; PETSCII
 232                   ;
 233                   SPC = $20
 234                   CR = $0d
 235                   RVS_ON = $12 
 236                   RVS_OFF = $92 
 237                   CLR = $93 
 238                   BLACK = $90
 239                   WHITE = $05
 240                   RED = $1c
 241                   GREEN = $1e
 242                   BLUE = $1f
 243                   ORANGE = $81
 244                   BROWN = $95
 245                   PURPLE = $9c
 246                   YELLOW = $9e
 247                   CYAN = $9f
 248                   LT_RED = $96
 249                   DK_GRAY = $97
 250                   GRAY = $98
 251                   LT_GRAY = $9b
 252                   LT_GREEN = $99
 253                   LT_BLUE = $9a
 254                   HOME = $13
 255                   DEL = $14
 256                   UP = $91
 257                   DOWN = $11
 258                   LEFT = $9d
 259                   RIGHT = $1d
 260                   SHIFT_ON = $09
 261                   SHIFT_OFF = $08
 262                   MODE_TEXT = $0e
 263                   MODE_GRAPH = $8e
 264                   F1 = $85
 265                   F2 = $86
 266                   F3 = $87
 267                   F4 = $88
 268                   F5 = $89
 269                   F6 = $8a
 270                   F7 = $8b
 271                   F8 = $8c 
 272                   DBL_QUOTE = $22 
 273                   SNGL_QUOTE = $27 
 274                   GRAPH_SLASH = $6e 
 275                   GRAPH_BACKSLASH = $6d 
 276                   PIPE = $7d 
 277                   DASH = $60 
 278                   
 279                   ;			
 280                   ; keyboard constants			
 281                   ;			
 282                   SHIFT_KEYS=$028d
 283                   KEY_SHIFT=%00000001
 284                   KEY_COMM=%000000010
 285                   KEY_CTRL=%00000100
 286                   
 287                   ;
 288                   ; zero page locations
 289                   ;
 290                   ; used by tape routines
 291                   ;
 292                   TSERVO = $92
 293                   TEOB = $96
 294                   TEMPXY = $97
 295                   TPARIT = $9b
 296                   TBYTFL = $9c
 297                   HDRTYP = $9e
 298                   PTR1 = $9e
 299                   PTR2 = $9f
 300                   TSFCNT = $a3
 301                   TBTCNT = $a4
 302                   CNTDN = $A5
 303                   BUFPNT = $a6
 304                   PASNUM = $a7
 305                   RIDATA = $aa
 306                   TCKS = $ab
 307                   CMP00 = $b0
 308                   CMPB01 = $b1
 309                   TAPE10 = $b2
 310                   TAPE11 = $b3
 311                   ;
 312                   ; used by rs-232
 313                   RIBUF0 = $f7
 314                   RIBUF1 = $f8
 315                   ROBUF0 = $f9
 316                   ROBUF1 = $fa
 317                   ;
 318                   ; unused
 319                   ;
 320                   MISC_PTR0 = $fb
 321                   MISC_PTR1 = $fc 
 322                   
 323                   ;
 324                   ; I/O Registers
 325                   ;
 326                   SPRITE0_X = $d000
 327                   SPRITE0_Y = $d001
 328                   SPRITE1_X = $d002
 329                   SPRITE1_Y = $d003
 330                   SPRITE2_X = $d004
 331                   SPRITE2_Y = $d005
 332                   SPRITE3_X = $d006
 333                   SPRITE3_Y = $d007
 334                   SPRITE4_X = $d008
 335                   SPRITE4_Y = $d009
 336                   SPRITE5_X = $d00a
 337                   SPRITE5_Y = $d00b
 338                   SPRITE6_X = $d00c
 339                   SPRITE6_Y = $d00d
 340                   SPRITE7_X = $d00e
 341                   SPRITE7_Y = $d00f
 342                   
 343                   SPRITE_MSB = $d010	; sprite 0-7 MSB of x coord
 344                   SCREEN_REG1= $d011	; bits 0-2:vertical raster roll
 345                   					; bit 3: screenm height (24/25 rows)
 346                   					; bit 4: screen off/on
 347                   					; bit 5: text/bitmap screen
 348                   					; bit 6: extended background mode
 349                   					; bit 7: 	read: current raster line
 350                   					;			write: line to generate IRQ at
 351                   					
 352                   RASTER_LINE = $d012 ; read: current raster line
 353                   LIGHTPEN_X = $d013
 354                   LIGHTPEN_Y = $d014
 355                   SPRITE_EN = $d015		; enable/disable bits for sprites 0-7
 356                   
 357                   SCREEN_CTRL = $d016	; 	bits 0-2:horiz raster scroll	
 358                   					;	bit 3: screen width - 38/40 cols	
 359                   					;	bit 4: multicolor mode	
 360                   						
 361                   SPRITE_2X_HT = $d017
 362                   MEM_SETUP = $d018	;	bits 1-3: in text mode, pointer to
 363                   					;		character memory
 364                   					; 	bits 4-7: pointer to screen memory
 365                   					
 366                   SPRITE_PRI = $d01b 	;	bits determine whether sprite x drawn  
 367                   					;		in front of/behind background
 368                   					
 369                   SPRITE_MULTI = $d01a ; sprites 0-7 multicolor on/off 
 370                   SPRITE_2X_WD = $d01d					
 371                   SPR2SPR_COLL = $d01e ; 	read: sprites have collided,					
 372                   					;	write: detect sprite-sprite collisions					
 373                   										
 374                   BORDER_COLOR = $d020 ; bits 0-3 										
 375                   BACKG_COLOR = $d021	; bits 0-3				
 376                   BKG_MULTI_CLR1 = $d022			
 377                   BKG_MULTI_CLR2 = $d023			
 378                   BKG_MULTI_CLR3 = $d024			
 379                   SPR_MULTI_CLR1 = $d025			
 380                   SPR_MULTI_CLR2 = $d026			
 381                   			
 382                   SPRITE0_COLOR = $d027 ; bits 0-3						
 383                   SPRITE1_COLOR = $d028 ; bits 0-3						
 384                   SPRITE2_COLOR = $d029 ; bits 0-3						
 385                   SPRITE3_COLOR = $d02a ; bits 0-3						
 386                   SPRITE4_COLOR = $d02b ; bits 0-3						
 387                   SPRITE5_COLOR = $d02c ; bits 0-3						
 388                   SPRITE6_COLOR = $d02d ; bits 0-3						
 389                   SPRITE7_COLOR = $d02e ; bits 0-3						
 390                   						
 391                   PROCESSOR_DDR = $0	; bits 0-7: set read/write for bit x 
 392                   					;	of processor port					
 393                   										
 394                   PROCESSOR_PORT = $1	; 	bit 0: RAM/ROM at $a000-bfff										
 395                   					;	bit 1: RAM/ROM at $e000-ffff										
 396                   					;	bit 2: RAM/IO ports at $d000-dfff										
 397                   					;	bits 3-5: datasette										
 398                   															
 399                   PRA  =  $dc00			; CIA#1 (Port Register A)
 400                   DDRA =  $dc02			; CIA#1 (Data Direction Register A)
 401                   
 402                   PRB  =  $dc01			; CIA#1 (Port Register B)
 403                   DDRB =  $dc03			; CIA#1 (Data Direction Register B)
 404                   
 405                   SCREEN_RAM = $400
 406                   COLOR_RAM = $d800
 407                   															  					
 408                   
   3                   .endif
   4                   
   5                   macros=1
   6                   
   7                   
   8                   push_axy	.macro
   9                   			pha
  10                   			txa
  11                   			pha
  12                   			tya
  13                   			pha
  14                   			.endm
  15                   
  16                   pull_axy	.macro						
  17                   			pla
  18                   			tay
  19                   			pla
  20                   			tax
  21                   			pla
  22                   			.endm			
  23                   ;
  24                   ;	"~" character prints as CR(13)
  25                   ;
  26                   print_str	.macro
  27                   			
  28                   			pha
  29                   			txa
  30                   			pha
  31                   			
  32                   			#print_str_addr rtxt
  33                   			
  34                   exit
  35                   			jmp end_text		
  36                   						
  37                   rtxt			.null "@1"
  38                   
  39                   end_text							
  40                   			pla						
  41                   			tax						
  42                   			pla						
  43                   									
  44                   			.endm
  45                   
  46                   print_str_addr .macro			
  47                   			ldx #0
  48                   			
  49                   loop			
  50                   			lda \1,x
  51                   			beq exit
  52                   			
  53                   			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54                   			bne print
  55                   			
  56                   			lda #CR
  57                   			
  58                   print			
  59                   			jsr CHROUT			
  60                   			inx			
  61                   			bne loop			
  62                   			.endm			
  63                   			
  64                   ;print_str_cr .segment			
  65                   ;			#print_str "@1"			
  66                   ;			#print_char 13			
  67                   ;			.endm			
  68                   						
  69                   
  70                   print_int	.macro
  71                   			pha
  72                   			tya
  73                   			pha
  74                   			
  75                   			lda #>\1
  76                   			ldy #<\1
  77                   			;jsr LINPRT
  78                   			#print_ay			
  79                   			
  80                   			pla
  81                   			tay
  82                   			pla
  83                   			.endm
  84                   
  85                   print_int_var .macro
  86                   			pha
  87                   			tya
  88                   			pha
  89                   			
  90                   			lda \1+1
  91                   			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
  94                   			
  95                   			pla
  96                   			tay
  97                   			pla
  98                   			.endm
  99                   
 100                   ; loads a,y with the value of the int pointed to 
 101                   ;	by 16-bit ptr \1
 102                   get_ptr_int	.macro
 103                   			
 104                   			ldy #0
 105                   			lda (\1),y
 106                   			
 107                   			pha
 108                   			iny
 109                   			lda (\1),y
 110                   			
 111                   			tax
 112                   			pla
 113                   			tay
 114                   			txa
 115                   
 116                   			.endm
 117                   ;
 118                   ; print a 16-bit int referenced by the
 119                   ;	zero-page 16-bit pointer starting at \1
 120                   ;
 121                   print_int_ptr .macro
 122                   			#push_axy			
 123                   			
 124                   			#get_ptr_int \1			
 125                   
 126                   			#print_ay
 127                   			
 128                   			#pull_axy
 129                   			.endm
 130                   
 131                   print_char_ptr .macro			
 132                   			#push_axy			
 133                   						
 134                   			ldy #0
 135                   			lda (\1),y						
 136                   									
 137                   			jsr CHROUT			
 138                   						
 139                   			#pull_axy			
 140                   			.endm			
 141                   						
 142                   ;
 143                   ; print a zt string referenced by the zero-page 
 144                   ;	16-bit pointer starting at \1
 145                   ;
 146                   print_str_ptr .macro
 147                   			#push_axy			
 148                   
 149                   			ldy #0
 150                   			
 151                   loop			
 152                   			lda (\1),y
 153                   			beq exit
 154                   			
 155                   			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
 156                   			bne print
 157                   			
 158                   			lda #CR
 159                   			
 160                   print			
 161                   			jsr CHROUT			
 162                   			iny			
 163                   			bne loop			
 164                   
 165                   ;finished						
 166                   ;			#pull_axy
 167                   ;			jmp exit
 168                   ;			
 169                   ;temp_a		.byte 00			
 170                   ;temp_y		.byte 00			
 171                   
 172                   exit		
 173                   			#pull_axy
 174                   			.endm
 175                   
 176                   ;
 177                   ;	
 178                   ;
 179                   print_ay	.macro
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183                   			jsr GIVAYF
 184                   			jsr FOUT
 185                   			jsr STROUT
 186                   			
 187                   			pull_axy
 188                   			.endm
 189                   			
 190                   
 191                   print_char	.macro
 192                   			pha	
 193                   				
 194                   			lda #\1
 195                   			jsr CHROUT
 196                   			
 197                   			pla
 198                   			.endm
 199                   			
 200                   print_spc	.macro			
 201                   			#print_char SPC			
 202                   			.endm			
 203                   						
 204                   print_cr	.macro						
 205                   			#print_char CR						
 206                   			.endm						
 207                   															
 208                   			
 209                   print_a		.macro
 210                   			
 211                   			sta temp
 212                   			txa
 213                   			pha
 214                   			
 215                   			lda temp
 216                   			#print_a_bare
 217                   			
 218                   			;jsr A_TO_FAC1
 219                   			;jsr FOUT
 220                   			;jsr STROUT
 221                   ;			pha
 222                   ;			tya
 223                   ;			pha
 224                   ;			
 225                   ;			lda temp
 226                   ;			ldy #0
 227                   ;			#print_ay
 228                   ;			
 229                   ;			pla
 230                   ;			tay
 231                   ;			pla
 232                   			
 233                   			pla
 234                   			tax
 235                   			lda temp	
 236                   			jmp exit	
 237                   				
 238                   temp		.byte 00				
 239                   
 240                   exit				
 241                   			.endm
 242                   
 243                   print_a_bare .macro			
 244                   			tax			
 245                   			lda #0
 246                   			
 247                   			jsr LINPRT
 248                   			
 249                   			.endm
 250                   			
 251                   			
 252                   print_byte	.macro
 253                   			pha
 254                   			txa
 255                   			pha
 256                   
 257                   			lda #\1
 258                   			
 259                   			#print_a_bare
 260                   			
 261                   			pla
 262                   			tax
 263                   			pla
 264                   			.endm
 265                   			
 266                   print_ptr	.macro
 267                   			
 268                   			pha
 269                   			tya
 270                   			pha
 271                   			
 272                   			lda \1+1
 273                   			ldy \1+2
 274                   			jsr LINPRT
 275                   			
 276                   			pla
 277                   			tay
 278                   			pla
 279                   			.endm
 280                   			
 281                   ;			
 282                   ;  increment a 16-bit value 
 283                   ; 			
 284                   inc16		.macro					
 285                   			;#print_str "inc16"					
 286                   								
 287                   ;			pha					
 288                   ;								
 289                   ;			clc
 290                   ;			lda \1					
 291                   ;			#print_str "inc16:a="					
 292                   ;			#print_a					
 293                   ;			#print_char 13					
 294                   ;			adc #1					
 295                   ;			#print_str "inc16:after inc, a="				
 296                   ;			#print_a				
 297                   ;			#print_char 13				
 298                   ;							
 299                   ;			sta \1					
 300                   ;			lda \2					
 301                   ;			adc #0					
 302                   ;			sta \2					
 303                   ;								
 304                   ;			pla								
 305                   											
 306                   			.ifdef DEBUG_MACROS								
 307                   				#print_str "inc16:before="								
 308                   				#print_int \1								
 309                   				#print_char CR								
 310                   			.endif								
 311                   											
 312                   			inc \1					
 313                   			bne done					
 314                   								
 315                   			inc \1+1					
 316                   								
 317                   								
 318                   done								
 319                   			.ifdef DEBUG_MACROS			
 320                   				#print_str "inc16:after="			
 321                   				#print_int \1			
 322                   				#print_char CR			
 323                   			.endif			
 324                   						
 325                   			.endm								
 326                   
 327                   ;											
 328                   ; store a 16-bit constant \2 in location \1											
 329                   ;	NOTE: does not save contents of A!											
 330                   ;											
 331                   store16		.macro											
 332                   														
 333                   			lda #<\1											
 334                   			sta \2											
 335                   														
 336                   			lda #>\1											
 337                   			sta \2+1											
 338                   														
 339                   			.endm											
 340                   
 341                   ;											
 342                   ; store the value of 16-bit var \2 in location \1											
 343                   ;	NOTE: does not save contents of A!											
 344                   ;											
 345                   store16var	.macro											
 346                   														
 347                   			lda \1											
 348                   			sta \2											
 349                   														
 350                   			lda \1+1											
 351                   			sta \2+1											
 352                   														
 353                   			.endm											
 354                   														
 355                   ;											
 356                   ; compare two 16-bit pointers.											
 357                   ;	OUT: A=0 if equal, 1 otherwise 											
 358                   ;											
 359                   cmp16vars	.macro						
 360                   			.ifdef DEBUG_MACROS						
 361                   				#print_str "cmp16vars:/1="						
 362                   				#print_int_var \1						
 363                   				#print_str " /2="						
 364                   				#print_int_var \2						
 365                   				#print_char SPC						
 366                   			.endif						
 367                   									
 368                   			lda \1						
 369                   			cmp \2										
 370                   			bne not_equal					
 371                   								
 372                   			lda \1+1					
 373                   			cmp \2+1					
 374                   			bne not_equal					
 375                   equal								
 376                   			.ifdef DEBUG_MACROS					
 377                   				#print_str "EQUAL!"					
 378                   			.endif					
 379                   			lda #0								
 380                   			beq exit	;always taken							
 381                   										
 382                   not_equal										
 383                   			lda #1										
 384                   								
 385                   exit																
 386                   			.ifdef DEBUG_MACROS															
 387                   				#print_char CR															
 388                   			.endif															
 389                   			.endm						
 390                   
 391                   									
 392                   ;									
 393                   ; compare a 16-bit var to a constant									
 394                   ;	OUT: A=0 if equal, 1 otherwise 											
 395                   ;									
 396                   cmp16const	.macro						
 397                   			.ifdef DEBUG_MACROS						
 398                   				#print_str "cmp16const:/1="						
 399                   				#print_int \1						
 400                   				#print_str " /2="						
 401                   				#print_int \2						
 402                   				#print_char SPC						
 403                   			.endif						
 404                   																		
 405                   			lda \1						
 406                   			cmp #<\2					
 407                   			bne not_equal					
 408                   								
 409                   			lda \1+1					
 410                   			cmp #>\2					
 411                   			bne not_equal					
 412                   								
 413                   equal								
 414                   			.ifdef DEBUG_MACROS					
 415                   				#print_str "EQUAL!"					
 416                   			.endif					
 417                   			lda #0					
 418                   			beq exit	; always taken					
 419                   								
 420                   not_equal								
 421                   			.ifdef DEBUG_MACROS					
 422                   				#print_str "NOT EQUAL!"					
 423                   			.endif					
 424                   			lda #1								
 425                   								
 426                   exit																
 427                   			.ifdef DEBUG_MACROS															
 428                   				#print_char CR															
 429                   			.endif															
 430                   			.endm						
 431                   
 432                   ;									
 433                   ; 16-bit ints: \1 = \1+\2						
 434                   ;									
 435                   add16		.macro									
 436                   			clc									
 437                   												
 438                   			lda \1									
 439                   			adc \2									
 440                   			sta \1									
 441                   												
 442                   			lda \1+1
 443                   			adc \2+1
 444                   			sta \1+1
 445                   			
 446                   			clc
 447                   			.endm
 448                   			
 449                   			 									
 450                   
   2                   
   3                   FOR					.segment
   4                   					.block					
   5                   FOR_init			
   6                   					#store16 \1,for_index
   7                   					#store16 \2,for_limit
   8                   					#store16 \3,for_inc			
   9                   								
  10                   					.ifdef DEBUG_MACROS			
  11                   						#print_int_var for_index			
  12                   						#print_spc			
  13                   						#print_int_var for_limit			
  14                   						#print_spc			
  15                   						#print_int_var for_inc			
  16                   						#print_cr			
  17                   					.endif			
  18                   								
  19                   FOR_loop					
  20                   					.endm
  21                   					
  22                   NEXT				.segment
  23                   					pha
  24                   					
  25                   					jsr STOP	; RUN/STOP pressed?
  26                   					bne NEXT_compare
  27                   					jmp FOR_exit
  28                   
  29                   NEXT_compare
  30                   					#cmp16vars for_index,for_limit
  31                   					beq FOR_exit
  32                   					 					
  33                   					pla
  34                   					
  35                   					#add16 for_index,for_inc 
  36                   					
  37                   					jmp FOR_loop
  38                   					
  39                   for_index			.word 00
  40                   for_limit			.word 00
  41                   for_inc				.word 00
  42                   
  43                   FOR_exit
  44                   ; we didn't get a chance to empty the stack earlier
  45                   					pla				
  46                   
  47                   					.bend
  48                   					.endm
  49                   ;
  50                   ;	Syntax is: FOR1 <varname>,<start-index>,<end-index>
  51                   ;FOR1				.macro
  52                   ;	for_@1	
  53                   ;					.byte <\2, >\2					
  54                   ;
  55                   ;for_start_@1
  56                   ;					.endm
  57                   ;					
  58                   ;NEXT1				.macro					
  59                   ;					#inc16 for_index_@1
  60                   ;					#cmp16const for_@1,\3			
  61                   ;					bcc for_start_@1
  62                   ;					
  63                   ;					.endm
  64                   
  65                   
   2                   
   3                   DEBUG_MACROS=1
   4                   
   5                   *= $801
   6                   .block
   7 0801 0b 08 0a 00 
   8 0805 9e           		.byte $9e
   9 0806 32 30 36 31  		.null "2061"
     080a 00 
  10 080b 00 00        		s .word 0
  11                   .bend
  12                   					
  13                   					#FOR 10,20,1 
   4                   					.block					
   5                   FOR_init			
   6                   					#store16 \1,for_index
 332                   														
 333 080d a9 0a        			lda #<\1											
 334 080f 8d a4 09     			sta \2											
 335                   														
 336 0812 a9 00        			lda #>\1											
 337 0814 8d a5 09     			sta \2+1											
 338                   														
   7                   					#store16 \2,for_limit
 332                   														
 333 0817 a9 14        			lda #<\1											
 334 0819 8d a6 09     			sta \2											
 335                   														
 336 081c a9 00        			lda #>\1											
 337 081e 8d a7 09     			sta \2+1											
 338                   														
   8                   					#store16 \3,for_inc			
 332                   														
 333 0821 a9 01        			lda #<\1											
 334 0823 8d a8 09     			sta \2											
 335                   														
 336 0826 a9 00        			lda #>\1											
 337 0828 8d a9 09     			sta \2+1											
 338                   														
   9                   								
  10                   					.ifdef DEBUG_MACROS			
  11                   						#print_int_var for_index			
  86 082b 48           			pha
  87 082c 98           			tya
  88 082d 48           			pha
  89                   			
  90 082e ad a5 09     			lda \1+1
  91 0831 ac a4 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 0834 20 91 b3     			jsr GIVAYF
 184 0837 20 dd bd     			jsr FOUT
 185 083a 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 083d 68           			pla
  96 083e a8           			tay
  97 083f 68           			pla
  12                   						#print_spc			
 201                   			#print_char SPC			
 192 0840 48           			pha	
 193                   				
 194 0841 a9 20        			lda #\1
 195 0843 20 d2 ff     			jsr CHROUT
 196                   			
 197 0846 68           			pla
  13                   						#print_int_var for_limit			
  86 0847 48           			pha
  87 0848 98           			tya
  88 0849 48           			pha
  89                   			
  90 084a ad a7 09     			lda \1+1
  91 084d ac a6 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 0850 20 91 b3     			jsr GIVAYF
 184 0853 20 dd bd     			jsr FOUT
 185 0856 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 0859 68           			pla
  96 085a a8           			tay
  97 085b 68           			pla
  14                   						#print_spc			
 201                   			#print_char SPC			
 192 085c 48           			pha	
 193                   				
 194 085d a9 20        			lda #\1
 195 085f 20 d2 ff     			jsr CHROUT
 196                   			
 197 0862 68           			pla
  15                   						#print_int_var for_inc			
  86 0863 48           			pha
  87 0864 98           			tya
  88 0865 48           			pha
  89                   			
  90 0866 ad a9 09     			lda \1+1
  91 0869 ac a8 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 086c 20 91 b3     			jsr GIVAYF
 184 086f 20 dd bd     			jsr FOUT
 185 0872 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 0875 68           			pla
  96 0876 a8           			tay
  97 0877 68           			pla
  16                   						#print_cr			
 205                   			#print_char CR						
 192 0878 48           			pha	
 193                   				
 194 0879 a9 0d        			lda #\1
 195 087b 20 d2 ff     			jsr CHROUT
 196                   			
 197 087e 68           			pla
  17                   					.endif			
  18                   								
  19                   FOR_loop					
  14                   					;#FOR 10,20,1 
  15                   						;#test1 sFF1,"hello string"
  16                   						#print_str "hello string "
  27                   			
  28 087f 48           			pha
  29 0880 8a           			txa
  30 0881 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 0882 a2 00        			ldx #0
  48                   			
  49                   loop			
  50 0884 bd 98 08     			lda \1,x
  51 0887 f0 0c        			beq exit
  52                   			
  53 0889 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 088b d0 02        			bne print
  55                   			
  56 088d a9 0d        			lda #CR
  57                   			
  58                   print			
  59 088f 20 d2 ff     			jsr CHROUT			
  60 0892 e8           			inx			
  61 0893 d0 ef        			bne loop			
  33                   			
  34                   exit
  35 0895 4c a6 08     			jmp end_text		
  36                   						
  37 0898 48 45 4c 4c  rtxt			.null "@1"
     089c 4f 20 53 54 
     08a0 52 49 4e 47 
     08a4 20 00 
  38                   
  39                   end_text							
  40 08a6 68           			pla						
  41 08a7 aa           			tax						
  42 08a8 68           			pla						
  43                   									
  17                   						#print_int_var for_index
  86 08a9 48           			pha
  87 08aa 98           			tya
  88 08ab 48           			pha
  89                   			
  90 08ac ad a5 09     			lda \1+1
  91 08af ac a4 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 08b2 20 91 b3     			jsr GIVAYF
 184 08b5 20 dd bd     			jsr FOUT
 185 08b8 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 08bb 68           			pla
  96 08bc a8           			tay
  97 08bd 68           			pla
  18                   						#print_cr
 205                   			#print_char CR						
 192 08be 48           			pha	
 193                   				
 194 08bf a9 0d        			lda #\1
 195 08c1 20 d2 ff     			jsr CHROUT
 196                   			
 197 08c4 68           			pla
  19                   					#NEXT
  23 08c5 48           					pha
  24                   					
  25 08c6 20 e1 ff     					jsr STOP	; RUN/STOP pressed?
  26 08c9 d0 03        					bne NEXT_compare
  27 08cb 4c aa 09     					jmp FOR_exit
  28                   
  29                   NEXT_compare
  30                   					#cmp16vars for_index,for_limit
 360                   			.ifdef DEBUG_MACROS						
 361                   				#print_str "cmp16vars:/1="						
  27                   			
  28 08ce 48           			pha
  29 08cf 8a           			txa
  30 08d0 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 08d1 a2 00        			ldx #0
  48                   			
  49                   loop			
  50 08d3 bd e7 08     			lda \1,x
  51 08d6 f0 0c        			beq exit
  52                   			
  53 08d8 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 08da d0 02        			bne print
  55                   			
  56 08dc a9 0d        			lda #CR
  57                   			
  58                   print			
  59 08de 20 d2 ff     			jsr CHROUT			
  60 08e1 e8           			inx			
  61 08e2 d0 ef        			bne loop			
  33                   			
  34                   exit
  35 08e4 4c f5 08     			jmp end_text		
  36                   						
  37 08e7 43 4d 50 31  rtxt			.null "@1"
     08eb 36 56 41 52 
     08ef 53 3a 2f 31 
     08f3 3d 00 
  38                   
  39                   end_text							
  40 08f5 68           			pla						
  41 08f6 aa           			tax						
  42 08f7 68           			pla						
  43                   									
 362                   				#print_int_var \1						
  86 08f8 48           			pha
  87 08f9 98           			tya
  88 08fa 48           			pha
  89                   			
  90 08fb ad a5 09     			lda \1+1
  91 08fe ac a4 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 0901 20 91 b3     			jsr GIVAYF
 184 0904 20 dd bd     			jsr FOUT
 185 0907 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 090a 68           			pla
  96 090b a8           			tay
  97 090c 68           			pla
 363                   				#print_str " /2="						
  27                   			
  28 090d 48           			pha
  29 090e 8a           			txa
  30 090f 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 0910 a2 00        			ldx #0
  48                   			
  49                   loop			
  50 0912 bd 26 09     			lda \1,x
  51 0915 f0 0c        			beq exit
  52                   			
  53 0917 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 0919 d0 02        			bne print
  55                   			
  56 091b a9 0d        			lda #CR
  57                   			
  58                   print			
  59 091d 20 d2 ff     			jsr CHROUT			
  60 0920 e8           			inx			
  61 0921 d0 ef        			bne loop			
  33                   			
  34                   exit
  35 0923 4c 2b 09     			jmp end_text		
  36                   						
  37 0926 20 2f 32 3d  rtxt			.null "@1"
     092a 00 
  38                   
  39                   end_text							
  40 092b 68           			pla						
  41 092c aa           			tax						
  42 092d 68           			pla						
  43                   									
 364                   				#print_int_var \2						
  86 092e 48           			pha
  87 092f 98           			tya
  88 0930 48           			pha
  89                   			
  90 0931 ad a7 09     			lda \1+1
  91 0934 ac a6 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 0937 20 91 b3     			jsr GIVAYF
 184 093a 20 dd bd     			jsr FOUT
 185 093d 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 0940 68           			pla
  96 0941 a8           			tay
  97 0942 68           			pla
 365                   				#print_char SPC						
 192 0943 48           			pha	
 193                   				
 194 0944 a9 20        			lda #\1
 195 0946 20 d2 ff     			jsr CHROUT
 196                   			
 197 0949 68           			pla
 366                   			.endif						
 367                   									
 368 094a ad a4 09     			lda \1						
 369 094d cd a6 09     			cmp \2										
 370 0950 d0 2f        			bne not_equal					
 371                   								
 372 0952 ad a5 09     			lda \1+1					
 373 0955 cd a7 09     			cmp \2+1					
 374 0958 d0 27        			bne not_equal					
 375                   equal								
 376                   			.ifdef DEBUG_MACROS					
 377                   				#print_str "EQUAL!"					
  27                   			
  28 095a 48           			pha
  29 095b 8a           			txa
  30 095c 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 095d a2 00        			ldx #0
  48                   			
  49                   loop			
  50 095f bd 73 09     			lda \1,x
  51 0962 f0 0c        			beq exit
  52                   			
  53 0964 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 0966 d0 02        			bne print
  55                   			
  56 0968 a9 0d        			lda #CR
  57                   			
  58                   print			
  59 096a 20 d2 ff     			jsr CHROUT			
  60 096d e8           			inx			
  61 096e d0 ef        			bne loop			
  33                   			
  34                   exit
  35 0970 4c 7a 09     			jmp end_text		
  36                   						
  37 0973 c5 d1 d5 c1  rtxt			.null "@1"
     0977 cc 21 00 
  38                   
  39                   end_text							
  40 097a 68           			pla						
  41 097b aa           			tax						
  42 097c 68           			pla						
  43                   									
 378                   			.endif					
 379 097d a9 00        			lda #0								
 380 097f f0 02        			beq exit	;always taken							
 381                   										
 382                   not_equal										
 383 0981 a9 01        			lda #1										
 384                   								
 385                   exit																
 386                   			.ifdef DEBUG_MACROS															
 387                   				#print_char CR															
 192 0983 48           			pha	
 193                   				
 194 0984 a9 0d        			lda #\1
 195 0986 20 d2 ff     			jsr CHROUT
 196                   			
 197 0989 68           			pla
 388                   			.endif															
  31 098a f0 1e        					beq FOR_exit
  32                   					 					
  33 098c 68           					pla
  34                   					
  35                   					#add16 for_index,for_inc 
 436 098d 18           			clc									
 437                   												
 438 098e ad a4 09     			lda \1									
 439 0991 6d a8 09     			adc \2									
 440 0994 8d a4 09     			sta \1									
 441                   												
 442 0997 ad a5 09     			lda \1+1
 443 099a 6d a9 09     			adc \2+1
 444 099d 8d a5 09     			sta \1+1
 445                   			
 446 09a0 18           			clc
  36                   					
  37 09a1 4c 7f 08     					jmp FOR_loop
  38                   					
  39 09a4 00 00        for_index			.word 00
  40 09a6 00 00        for_limit			.word 00
  41 09a8 00 00        for_inc				.word 00
  42                   
  43                   FOR_exit
  44                   ; we didn't get a chance to empty the stack earlier
  45 09aa 68           					pla				
  46                   
  47                   					.bend
  20                   					
  21                   					 
  22                   ;					#FOR1 label,1,1000					
  23                   ;										
  24                   ;						#print_str "Count is "					
  25                   ;						#print_int i					
  26                   ;						#print_cr					
  27                   ;										
  28                   ;					#NEXT1 i										 			 					
  29                   
  30 09ab 60           					rts					
  31                   
