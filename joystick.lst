   1                   				*=$c000
   2                   
   3                   .include "const.asm"				
   1                   constants=1			
   2                   
   3                   ;
   4                   ; utility routines
   5                   ;
   6                   CLR_SCREEN = $e544
   7                   PLOTK = $e50a			; read/set cursor row(x), col(y) 
   8                   SCROL = $e8ea			; scroll the screen up 1 line 
   9                   DSPP = $ea31			; read the screen & put char in A, color in X 
  10                   MOVE_UP = $a3bf			; move a block of memory up, or move memory  
  11                   						;	from one non-overlapping region to another.
  12                   						;	$5f-$60=source block starting address
  13                   						;	$5a-5b=source block ending address +1
  14                   						;	$58-59=destination's ending address +1
  15                   
  16                   
  17                   ;
  18                   ;	I/O ROUTINES
  19                   ;
  20                   CHROUT = $FFD2			; write byte to default output
  21                   CHRIN = $FFCF			; read byte from default input
  22                   
  23                   SETLFS = $FFBA			; set logical file numbers (open a,x,y)
  24                   SETNAM = $FFBD			; set file name(a=len,x/y=lo/hi for pointer)
  25                   OPEN = $FFC0			; open file (out:c=err, a=1,2,4,5,8 error code)
  26                   CLOSE = $FFC3			; close file (a=fileno)
  27                   CHKIN = $FFC6			; set file as default input(a=filenumber,C=error)
  28                   CHKOUT = $FFC9			; set file as default output(a=filenumber,C=error)
  29                   CLRCHN = $FFCC			; close default input/output files
  30                   LOAD = $FFD5
  31                   SAVE = $FFD8
  32                   GETIN = $FFE4			; read byte from default input (diff with CHRIN?)
  33                   CLALL = $FFE7			; clear file table & call CLRCHN
  34                   READST = $ffb7			; read STatus, leaves it in A
  35                   STATUS = $90			; ST for serial devices.						
  36                   						;	For serial devices:						
  37                   						;		bit 0:timeout (write)
  38                   						;		bit 1:timeout (read)
  39                   						;		bit 6:EOF
  40                   						;		bit 7:device not present 						
  41                   
  42                   STROUT = $ab1e			; print zt string,addr in A/Y
  43                   LINPRT = $BDCD			; print UNSIGNED int in A/X 
  44                   
  45                   PRTSPC = $ab4d			; print a space character
  46                   CRDO = $aad7			; print a CR character, followed by LF
  47                   						;	if channel > 128
  48                   						
  49                   STOP = $ffe1			; check for STOP key. If pressed, 
  50                   						; 	set Z (BEQ), call CLRCHN, print "break".
  51                   FTXTPTR = $7a			; pointer into (usually BASIC) text						
  52                   
  53                   ;
  54                   ;	FAC MATH
  55                   ;
  56                   MOVFA = $bbfc			; copy FAC2 to FAC1
  57                   						
  58                   FAC1 = $61				; $61:exponent (power of 2). 128 or greater means 
  59                   						;	negative exponent
  60                   						; $62-65:mantissa. Also, $62-63 hold result of
  61                   						;	FAC1-to-int conversions
  62                   						; $66:sign. 0=positive, $ff=negative
  63                   						
  64                   FAC2 = $69				; same structure as FAC1
  65                   
  66                   
  67                   AADD = $bd7e			; add A to FAC1
  68                   
  69                   ADDH = $b849			; add 0.5 to FAC1 for rounding
  70                   FSUBT = $b853			; FAC1=FAC2 - FAC1
  71                   FADDT = $b86f			; FAC1=FAC@ + FAC1
  72                   NEGFAC = $b947			; FAC1=negative (2's complement) of FAC1
  73                   FMULTT = $ba30			; FAC1=FAC1 * FAC2
  74                   FDIVT = $bb14			; FAC1=FAC2 / FAC1
  75                   ROUND = $bc2b			; FAC1 = ROUND(FAC1)
  76                   SIGN = $bc2b			; A=(0 if FAC1=0, 1 if FAC1>0, $FF(-1) otherwise)
  77                   						
  78                   FOUTIM = $be68			; convert TI to ASCII string at $100 
  79                   SQR = $bf71				; FAC1=SQR(FAC1) 
  80                   FPWRT = $bf78			; FAC1=FAC2^FAC1 
  81                   NEGOP = $bfb4			; FAC1 = NOT(FAC1) 
  82                   EXP = $bfed				; FAC1=e^EXP1 
  83                   RND = $e097				; FAC1=RND(FAC1), using BASIC's RND() logic 
  84                   COS = $e264				; FAC1=COS(FAC1) 
  85                   SIN = $e26b				; FAC1=SIN(FAC1) 
  86                   TAN = $e2b4				; FAC1=TAN(FAC1) 
  87                   ATN = $e30e				; FAC1=ATAN(FAC1) 
  88                   EVAL = $ae83			; evaluate an arithmetic term from ASCII  
  89                   						;	to a floating point value.   
  90                   
  91                   ;
  92                   ;	FAC CONVERSION ROUTINES
  93                   ;
  94                   PETSCII_TO_FAC1=$bcf3	; convert a PETSCII string containing 
  95                   						; 	a FP constant, to FAC1. before calling,  
  96                   						; 	store the address of the string in $7a/7b, 
  97                   						; 	then JSR $79.
  98                   						
  99                   STRVAL = $b7b5			; convert PETSCII-string to FAC1. Expects 
 100                   						;   string-address in $22/$23 and 
 101                   						;	length of string in accumulator.
 102                   						
 103                   GIVAYF = $b391			; convert signed int in Y/A to FAC1; range -32768 to 32767
 104                   FACINX = $B1AA			; convert FAC1 to 2-byte signed int in A/Y
 105                   FIN = $bfc3				; convert string (pointed to by TXTPTR) 
 106                   						;	to float in FAC1
 107                   FOUT = $bddd			; convert FAC1 to ASCII string, starting at $100
 108                   						; 	and ending with a 0 term. On exit, A/Y holds
 109                   						; 	start address, so STROUT can be called.
 110                   A_TO_FAC1 = $bc3c		; convert unsigned 8-bit int in A to FAC1						
 111                   SNGET = $b3a2  			; convert unsigned 8-bit int in Y to FAC1 
 112                   QINT = $bc9b			; convert FAC1 into 4-byte signed int from $62-65 
 113                   GETADR = $b7f7			; convert FAC1 to a 16-bit int, in $14/$15						
 114                    
 115                    
 116                   ;
 117                   ; interrupt vectors
 118                   ;
 119                   CVINV = $314			; point to IRQ handler, normally $ea31.
 120                   						;	NOTE: A,X,Y are saved on the stack before calling,
 121                   						;		but they are NOT automatically restored
 122                   						
 123                   CBINV = $316			; BRK interrupt handler. Normally $fe66.  
 124                   NMINV = $318			; NMI handler, normally $fe47.  
 125                   						;	NOTE: to disable RS/RESTORE, store a 0 in $318.
 126                   						
 127                   
 128                   						  						 
 129                   
 130                   ;
 131                   ; passing data between basic and ml
 132                   ;
 133                   
 134                   
 135                   A_STORAGE = $30c		; the registers are read from these 
 136                   X_STORAGE = $30d 		;	locations before running a SYS routine,
 137                   Y_STORAGE = $30e 		; 	and the results are stored back into 
 138                   P_STORAGE = $30f 		;	them after the RTS. doesn't apply to USR.
 139                   
 140                   USERADD = $311			; the 16-bit address of a USR routine can be 
 141                   						; 	put into this vector. for example:
 142                   						;		x=usr(17) 								
 143                   						;	...puts the value of 17 in FAC1, calls
 144                   						; 	the routine in $311-312, and assigns the
 145                   						;	value of FAC1 upon exiting, to the var x.
 146                   ;
 147                   ; other basic stuff
 148                   ;
 149                   CHRGET = $73			; reads the next character for processing by basic.
 150                   						;	sets P to indicate what kind of char,  
 151                   						; 	and returns the char in A. C=0-9,Z=end of stmt.
 152                   						
 153                   CHRGOT = $79			; does the same thing, but doesn't increment the						
 154                   						;	char pointer.						
 155                   												
 156                   VERCK = $A				; flag:0=LOAD,1=VERIFY												
 157                   VALTYP = $D				; flag:$FF=string,0=numeric							
 158                   INTFLG = $E				; flag:$80=int,0=fp												
 159                   INPFLG = $11			; flag:0=INPUT,$40=GET,$98=READ												
 160                   CHANNL = $13			; current logical file number (not dev#)												
 161                   TXTTAB = $2b			; beginning of BASIC text, normally $801 
 162                   MEMSIZ = $37			; end of BASIC-available memory 
 163                   CURLIN = $39			; current BASIC line#. $ff in $40 means immediate mode 
 164                   VARPNT = $47			; descriptor of current BASIC variable value 
 165                   OPMASK = $4D			; comparison operation flag: 1=<,2=> 
 166                   DSCPNT = $50			; $50-51 point to current string descriptor, 
 167                   						; 	$52 holds string length
 168                   						
 169                   ARISGN = $6f			; result of comparison between FAC1,FAC2						
 170                   						;	0=like signs, $ff=unlike signs						
 171                   
 172                   STKEY = $91				; value of the last row of the keybd when last scanned. 												 
 173                   						;	$ff=none,$fe=1,$fd=<-,$fb=CTRL,$ef=SPACE,
 174                   						;	$df=Commodore,$bf=Q,$7f=STOP.
 175                   						;	NOTE: this means that you can do this:
 176                   						;		LDA STKEY
 177                   						;		BPL handle_stop
 178                   						
 179                   VERCK2 = $93				; flag for load routine: 0=load/1=verify												
 180                   DFLTN = $99				; current default input device
 181                   DFLTO = $9A				; current default output device
 182                   TIME = $A0				; software jiffy clock, from $a0-a2. 
 183                   						;	24-bit count of jiffies (60/sec) since start.
 184                   						;	resets every 24 hours.
 185                   
 186                   FNLEN = $b7				; size of current filename						
 187                   LA = $b8				; current logical file number(for a different						
 188                   						;	purpose then $13)						
 189                   SA = $b9				; current secondary address												
 190                   FA = $ba				; current device number												
 191                   FNADR = $BB				; 2-byte pointer to filename												
 192                   LSTX = $c5				; matrix coordinate of *last* keypress; 64=none												
 193                   NDX = $c6				; # of characters in keyboard buffer												
 194                   RVS = $c7				; flag: print reverse characters? 0=no												
 195                   						;	NOTE: you can poke 0 here to cancel reverse mode												
 196                   SFDX = $cb				; matrix coords of *current* keypress; 64=none
 197                   BLNSW = $cc				; cursor blink enable:0=flash
 198                   GDBLN = $ce				; screen code of char under cursor
 199                   PNTR = $d3				; cursor column on current line
 200                   QTSW = $d4				; editor in quote mode? 0=no
 201                   TBLx = $d6				; current cursor physical line #
 202                   INSRT = $d8				; insert mode? >0 is # of inserts
 203                   USER = $f3				; 2-byte pointer to current screen color location
 204                   
 205                   COLOR = $286			; current foreground color for text
 206                   GDCOL = $287			; color of character under cursor
 207                   HIBASE = $288			; page of screen memory; normally contains 4(*256=1024)
 208                   						;	NOTE: $d018/$dd00 change ths *display*
 209                   						;	screen location - the one that shown onscreen.
 210                   						; 	this one is the memory written into by CHROUT,etc.
 211                   						
 212                   XMAX	= $289			; max keyvoard buffer size; should be <=10						
 213                   RPTFLAG = $28a			; flag: which keys should repeat?						
 214                   						;	0=normal,$80=all,$40=none						
 215                   												
 216                   SHFLAG = $653			; flag: modifier keys currently pressed?											
 217                   						;	bits: 1=SHIFT,2=Commodore,4=CTRL											
 218                   																	
 219                   MODE = $291				; flag: enable changing char sets with SHIFT/C= ?																	
 220                   						;	$80=disabled, 0=enabled																	
 221                   																							
 222                   AUTODN = $292			; flag: scroll screen on col 40/last line?																							
 223                   						;	0=yes; otherwise=no																							
 224                   																													
 225                   																													
 226                   																		 
 227                   BUF = $200				; BASIC line editor input buffer 
 228                    
 229                    												
 230                   ;
 231                   ; PETSCII
 232                   ;
 233                   SPC = $20
 234                   CR = $0d
 235                   RVS_ON = $12 
 236                   RVS_OFF = $92 
 237                   CLR = $93 
 238                   BLACK = $90
 239                   WHITE = $05
 240                   RED = $1c
 241                   GREEN = $1e
 242                   BLUE = $1f
 243                   ORANGE = $81
 244                   BROWN = $95
 245                   PURPLE = $9c
 246                   YELLOW = $9e
 247                   CYAN = $9f
 248                   LT_RED = $96
 249                   DK_GRAY = $97
 250                   GRAY = $98
 251                   LT_GRAY = $9b
 252                   LT_GREEN = $99
 253                   LT_BLUE = $9a
 254                   HOME = $13
 255                   DEL = $14
 256                   UP = $91
 257                   DOWN = $11
 258                   LEFT = $9d
 259                   RIGHT = $1d
 260                   SHIFT_ON = $09
 261                   SHIFT_OFF = $08
 262                   MODE_TEXT = $0e
 263                   MODE_GRAPH = $8e
 264                   F1 = $85
 265                   F2 = $86
 266                   F3 = $87
 267                   F4 = $88
 268                   F5 = $89
 269                   F6 = $8a
 270                   F7 = $8b
 271                   F8 = $8c 
 272                   DBL_QUOTE = $22 
 273                   SNGL_QUOTE = $27 
 274                   GRAPH_SLASH = $6e 
 275                   GRAPH_BACKSLASH = $6d 
 276                   PIPE = $7d 
 277                   DASH = $60 
 278                   
 279                   ;			
 280                   ; keyboard constants			
 281                   ;			
 282                   SHIFT_KEYS=$028d
 283                   KEY_SHIFT=%00000001
 284                   KEY_COMM=%000000010
 285                   KEY_CTRL=%00000100
 286                   
 287                   ;
 288                   ; zero page locations
 289                   ;
 290                   ; used by tape routines
 291                   ;
 292                   TSERVO = $92
 293                   TEOB = $96
 294                   TEMPXY = $97
 295                   TPARIT = $9b
 296                   TBYTFL = $9c
 297                   HDRTYP = $9e
 298                   PTR1 = $9e
 299                   PTR2 = $9f
 300                   TSFCNT = $a3
 301                   TBTCNT = $a4
 302                   CNTDN = $A5
 303                   BUFPNT = $a6
 304                   PASNUM = $a7
 305                   RIDATA = $aa
 306                   TCKS = $ab
 307                   CMP00 = $b0
 308                   CMPB01 = $b1
 309                   TAPE10 = $b2
 310                   TAPE11 = $b3
 311                   ;
 312                   ; used by rs-232
 313                   RIBUF0 = $f7
 314                   RIBUF1 = $f8
 315                   ROBUF0 = $f9
 316                   ROBUF1 = $fa
 317                   ;
 318                   ; unused
 319                   ;
 320                   MISC_PTR0 = $fb
 321                   MISC_PTR1 = $fc 
 322                   
 323                   ;
 324                   ; I/O Registers
 325                   ;
 326                   SPRITE0_X = $d000
 327                   SPRITE0_Y = $d001
 328                   SPRITE1_X = $d002
 329                   SPRITE1_Y = $d003
 330                   SPRITE2_X = $d004
 331                   SPRITE2_Y = $d005
 332                   SPRITE3_X = $d006
 333                   SPRITE3_Y = $d007
 334                   SPRITE4_X = $d008
 335                   SPRITE4_Y = $d009
 336                   SPRITE5_X = $d00a
 337                   SPRITE5_Y = $d00b
 338                   SPRITE6_X = $d00c
 339                   SPRITE6_Y = $d00d
 340                   SPRITE7_X = $d00e
 341                   SPRITE7_Y = $d00f
 342                   
 343                   SPRITE_MSB = $d010	; sprite 0-7 MSB of x coord
 344                   SCREEN_REG1= $d011	; bits 0-2:vertical raster roll
 345                   					; bit 3: screenm height (24/25 rows)
 346                   					; bit 4: screen off/on
 347                   					; bit 5: text/bitmap screen
 348                   					; bit 6: extended background mode
 349                   					; bit 7: 	read: current raster line
 350                   					;			write: line to generate IRQ at
 351                   					
 352                   RASTER_LINE = $d012 ; read: current raster line
 353                   LIGHTPEN_X = $d013
 354                   LIGHTPEN_Y = $d014
 355                   SPRITE_EN = $d015		; enable/disable bits for sprites 0-7
 356                   
 357                   SCREEN_CTRL = $d016	; 	bits 0-2:horiz raster scroll	
 358                   					;	bit 3: screen width - 38/40 cols	
 359                   					;	bit 4: multicolor mode	
 360                   						
 361                   SPRITE_2X_HT = $d017
 362                   MEM_SETUP = $d018	;	bits 1-3: in text mode, pointer to
 363                   					;		character memory
 364                   					; 	bits 4-7: pointer to screen memory
 365                   					
 366                   SPRITE_PRI = $d01b 	;	bits determine whether sprite x drawn  
 367                   					;		in front of/behind background
 368                   					
 369                   SPRITE_MULTI = $d01a ; sprites 0-7 multicolor on/off 
 370                   SPRITE_2X_WD = $d01d					
 371                   SPR2SPR_COLL = $d01e ; 	read: sprites have collided,					
 372                   					;	write: detect sprite-sprite collisions					
 373                   										
 374                   BORDER_COLOR = $d020 ; bits 0-3 										
 375                   BACKG_COLOR = $d021	; bits 0-3				
 376                   BKG_MULTI_CLR1 = $d022			
 377                   BKG_MULTI_CLR2 = $d023			
 378                   BKG_MULTI_CLR3 = $d024			
 379                   SPR_MULTI_CLR1 = $d025			
 380                   SPR_MULTI_CLR2 = $d026			
 381                   			
 382                   SPRITE0_COLOR = $d027 ; bits 0-3						
 383                   SPRITE1_COLOR = $d028 ; bits 0-3						
 384                   SPRITE2_COLOR = $d029 ; bits 0-3						
 385                   SPRITE3_COLOR = $d02a ; bits 0-3						
 386                   SPRITE4_COLOR = $d02b ; bits 0-3						
 387                   SPRITE5_COLOR = $d02c ; bits 0-3						
 388                   SPRITE6_COLOR = $d02d ; bits 0-3						
 389                   SPRITE7_COLOR = $d02e ; bits 0-3						
 390                   						
 391                   PROCESSOR_DDR = $0	; bits 0-7: set read/write for bit x 
 392                   					;	of processor port					
 393                   										
 394                   PROCESSOR_PORT = $1	; 	bit 0: RAM/ROM at $a000-bfff										
 395                   					;	bit 1: RAM/ROM at $e000-ffff										
 396                   					;	bit 2: RAM/IO ports at $d000-dfff										
 397                   					;	bits 3-5: datasette										
 398                   															
 399                   PRA  =  $dc00			; CIA#1 (Port Register A)
 400                   DDRA =  $dc02			; CIA#1 (Data Direction Register A)
 401                   
 402                   PRB  =  $dc01			; CIA#1 (Port Register B)
 403                   DDRB =  $dc03			; CIA#1 (Data Direction Register B)
 404                   
 405                   SCREEN_RAM = $400
 406                   COLOR_RAM = $d800
 407                   															  					
 408                   
   4                   
   5                   				
   6 c000 a9 7d        				LDA #$7D
   7 c002 8d e0 cf     				STA $CFE0
   8 c005 a9 00        				LDA #$00
   9 c007 8d e1 cf     				STA $CFE1
  10 c00a a9 7d        				LDA #$7D
  11 c00c 8d e2 cf     				STA $CFE2
  12 c00f a9 00        				LDA #$00
  13 c011 8d e3 cf     				STA $CFE3
  14 c014 a9 7d        				LDA #$7D
  15 c016 8d 00 d0     				STA SPRITE0_X
  16 c019 8d 01 d0     				STA SPRITE0_Y
  17 c01c 8d 02 d0     				STA SPRITE1_X
  18 c01f 8d 03 d0     				STA SPRITE1_Y
  19 c022 a9 00        				LDA #$00
  20 c024 8d 10 d0     				STA SPRITE_MSB
  21 c027 78           				SEI
  22 c028 a9 34        				LDA #<irq_routine
  23 c02a 8d 14 03     				STA $0314
  24 c02d a9 c0        				LDA #>irq_routine
  25 c02f 8d 15 03     				STA $0315
  26 c032 58           				CLI
  27 c033 60           				RTS
  28                   				
  29                   irq_routine				
  30 c034 a2 00        				LDX #$00
  31 c036 20 41 c0     				JSR jsr_c041
  32 c039 a2 01        				LDX #$01
  33 c03b 20 41 c0     				JSR jsr_c041
  34 c03e 4c 31 ea     				JMP $EA31
  35                   				
  36                   jsr_c041				
  37 c041 a9 03        				LDA #$03
  38 c043 8d 15 d0     				STA SPRITE_EN
  39 c046 a9 c0        				LDA #$C0
  40 c048 8d f8 07     				STA $07F8
  41 c04b a9 04        				LDA #$04
  42 c04d 8d 27 d0     				STA SPRITE0_COLOR
  43 c050 a9 03        				LDA #$03
  44 c052 8d 28 d0     				STA SPRITE1_COLOR
  45 c055 a9 c1        				LDA #$C1
  46 c057 8d f9 07     				STA $07F9
  47 c05a bd 00 dc     				LDA PRA,X
  48 c05d 29 0f        				AND #$0F
  49 c05f 9d e4 cf     				STA $CFE4,X
  50 c062 38           				SEC
  51 c063 a9 0f        				LDA #$0F
  52 c065 fd e4 cf     				SBC $CFE4,X
  53 c068 9d e8 cf     				STA $CFE8,X
  54 c06b a0 00        				LDY #$00
  55                   				
  56                   bc06d				
  57 c06d c8           				INY
  58 c06e 98           				TYA
  59 c06f dd e8 cf     				CMP $CFE8,X
  60 c072 d0 f9        				BNE bc06d
  61                   				
  62 c074 e0 01        				CPX #$01
  63 c076 d0 02        				BNE bc07a
  64                   				
  65 c078 a2 02        				LDX #$02
  66                   
  67                   bc07a				
  68 c07a 98           				TYA
  69 c07b 0a           				ASL A
  70 c07c a8           				TAY
  71 c07d b9 87 c0     				LDA vc087,Y
  72 c080 48           				PHA
  73 c081 b9 86 c0     				LDA vc086,Y
  74 c084 48           				PHA
  75 c085 60           				RTS
  76                   				
  77                   vc086				
  78 c086 01           				.byte $01
  79                   vc087
  80 c087 c2           				.byte $C2
  81 c088 d5 c1 d9 c1  				.byte $D5,$C1,$D9,$C1,$01 
     c08c 01 
  82 c08d c2 e1 c1 e5  				.byte $C2,$E1,$C1,$E5,$C1,$EC,$C1,$01,$C2,$DD
     c091 c1 ec c1 01 
     c095 c2 dd 
  83 c097 c1 fa c1 f3  				.byte $C1,$FA,$C1,$F3,$C1,$01,$C2				
     c09b c1 01 c2 
  84                   				;$A9,$32
  85                   				   
  86                   
  87                   				
  88                   ;				ORA ($C2,X)
  89                   ;				CMP $C1,X
  90                   ;				CMP $01C1,Y
  91                   ;				NOOP #$E1
  92                   ;				CMP ($E5,X)
  93                   ;				CMP ($EC,X)
  94                   ;				CMP ($01,X)
  95                   ;				NOOP #$DD
  96                   ;				CMP ($FA,X)
  97                   ;				CMP ($F3,X)
  98                   ;				CMP ($01,X)
  99                   ;				NOOP #$A9
 100                   ;				JAM
 101                   
 102                   jsr_c09e				
 103 c09e a9 32        				LDA #$32
 104 c0a0 dd 01 d0     				CMP SPRITE0_Y,X
 105 c0a3 b0 0c        				BCS bc0b1
 106 c0a5 bd 01 d0     				LDA SPRITE0_Y,X
 107 c0a8 38           				SEC
 108 c0a9 bd 01 d0     				LDA SPRITE0_Y,X
 109 c0ac e9 01        				SBC #$01
 110 c0ae 9d 01 d0     				STA SPRITE0_Y,X
 111                   bc0b1				
 112 c0b1 60           				RTS
 113                   				
 114                   jsr_c0b2				
 115 c0b2 a9 e5        				LDA #$E5
 116 c0b4 dd 01 d0     				CMP SPRITE0_Y,X
 117 c0b7 90 0c        				BCC bc0c5
 118 c0b9 bd 01 d0     				LDA SPRITE0_Y,X
 119 c0bc 18           				CLC
 120 c0bd bd 01 d0     				LDA SPRITE0_Y,X
 121 c0c0 69 01        				ADC #$01
 122 c0c2 9d 01 d0     				STA SPRITE0_Y,X
 123                   bc0c5				
 124 c0c5 60           				RTS
 125                   
 126                   jsr_c0c6			
 127 c0c6 38           				SEC
 128 c0c7 bd e0 cf     				LDA $CFE0,X
 129 c0ca e9 41        				SBC #$41
 130 c0cc 9d e4 cf     				STA $CFE4,X
 131 c0cf bd e1 cf     				LDA $CFE1,X
 132 c0d2 e9 01        				SBC #$01
 133 c0d4 1d e4 cf     				ORA $CFE4,X
 134 c0d7 90 0d        				BCC bc0e6
 135                   				
 136 c0d9 a9 41        				LDA #$41
 137 c0db 9d e0 cf     				STA $CFE0,X
 138 c0de a9 01        				LDA #$01
 139 c0e0 9d e1 cf     				STA $CFE1,X
 140 c0e3 4c f7 c0     				JMP jmp_c0f7
 141                   
 142                   bc0e6				
 143 c0e6 18           				CLC
 144 c0e7 bd e0 cf     				LDA $CFE0,X
 145 c0ea 69 01        				ADC #$01
 146 c0ec 9d e0 cf     				STA $CFE0,X
 147 c0ef bd e1 cf     				LDA $CFE1,X
 148 c0f2 69 00        				ADC #$00
 149 c0f4 9d e1 cf     				STA $CFE1,X
 150                   				
 151                   jmp_c0f7				
 152 c0f7 38           				SEC
 153 c0f8 bd e0 cf     				LDA $CFE0,X
 154 c0fb e9 00        				SBC #$00
 155 c0fd 9d e4 cf     				STA $CFE4,X
 156 c100 bd e1 cf     				LDA $CFE1,X
 157 c103 e9 01        				SBC #$01
 158 c105 1d e4 cf     				ORA $CFE4,X
 159 c108 90 13        				BCC bc11d
 160 c10a e0 02        				CPX #$02
 161 c10c f0 22        				BEQ bc130
 162 c10e ad 10 d0     				LDA SPRITE_MSB
 163 c111 09 01        				ORA #$01
 164 c113 8d 10 d0     				STA SPRITE_MSB
 165 c116 bd e0 cf     				LDA $CFE0,X
 166 c119 9d 00 d0     				STA SPRITE0_X,X
 167 c11c 60           				RTS
 168                   				
 169                   bc11d				
 170 c11d e0 02        				CPX #$02
 171 c11f f0 1e        				BEQ bc13f
 172 c121 ad 10 d0     				LDA SPRITE_MSB
 173 c124 29 fe        				AND #$FE
 174 c126 8d 10 d0     				STA SPRITE_MSB
 175 c129 bd e0 cf     				LDA $CFE0,X
 176 c12c 9d 00 d0     				STA SPRITE0_X,X
 177 c12f 60           				RTS
 178                   				
 179                   bc130				
 180 c130 ad 10 d0     				LDA SPRITE_MSB
 181 c133 09 02        				ORA #$02
 182 c135 8d 10 d0     				STA SPRITE_MSB
 183 c138 bd e0 cf     				LDA $CFE0,X
 184 c13b 9d 00 d0     				STA SPRITE0_X,X
 185 c13e 60           				RTS
 186                   				
 187                   bc13f				
 188 c13f ad 10 d0     				LDA SPRITE_MSB
 189 c142 29 fd        				AND #$FD
 190 c144 8d 10 d0     				STA SPRITE_MSB
 191 c147 bd e0 cf     				LDA $CFE0,X
 192 c14a 9d 00 d0     				STA SPRITE0_X,X
 193 c14d 60           				RTS
 194                   				
 195                   jsr_c14e				
 196 c14e 38           				SEC
 197 c14f bd e0 cf     				LDA $CFE0,X
 198 c152 e9 19        				SBC #$19
 199 c154 9d e4 cf     				STA $CFE4,X
 200 c157 bd e1 cf     				LDA $CFE1,X
 201 c15a e9 00        				SBC #$00
 202 c15c 1d e4 cf     				ORA $CFE4,X
 203 c15f b0 0d        				BCS bc16e
 204 c161 a9 18        				LDA #$18
 205 c163 9d e0 cf     				STA $CFE0,X
 206 c166 a9 00        				LDA #$00
 207 c168 9d e1 cf     				STA $CFE1,X
 208 c16b 4c 7f c1     				JMP jmp_c17f
 209                   				
 210                   bc16e				
 211 c16e 38           				SEC
 212 c16f bd e0 cf     				LDA $CFE0,X
 213 c172 e9 01        				SBC #$01
 214 c174 9d e0 cf     				STA $CFE0,X
 215 c177 bd e1 cf     				LDA $CFE1,X
 216 c17a e9 00        				SBC #$00
 217 c17c 9d e1 cf     				STA $CFE1,X
 218                   
 219                   jmp_c17f				
 220 c17f 38           				SEC
 221 c180 bd e0 cf     				LDA $CFE0,X
 222 c183 e9 00        				SBC #$00
 223 c185 9d e4 cf     				STA $CFE4,X
 224 c188 bd e1 cf     				LDA $CFE1,X
 225 c18b e9 01        				SBC #$01
 226 c18d 1d e4 cf     				ORA $CFE4,X
 227 c190 90 13        				BCC bc1a5
 228 c192 e0 02        				CPX #$02
 229 c194 f0 22        				BEQ bc1b8
 230 c196 ad 10 d0     				LDA SPRITE_MSB
 231 c199 09 01        				ORA #$01
 232 c19b 8d 10 d0     				STA SPRITE_MSB
 233 c19e bd e0 cf     				LDA $CFE0,X
 234 c1a1 9d 00 d0     				STA SPRITE0_X,X
 235 c1a4 60           				RTS
 236                   				
 237                   bc1a5				
 238 c1a5 e0 02        				CPX #$02
 239 c1a7 f0 1e        				BEQ bc1c7
 240 c1a9 ad 10 d0     				LDA SPRITE_MSB
 241 c1ac 29 fe        				AND #$FE
 242 c1ae 8d 10 d0     				STA SPRITE_MSB
 243 c1b1 bd e0 cf     				LDA $CFE0,X
 244 c1b4 9d 00 d0     				STA SPRITE0_X,X
 245 c1b7 60           				RTS
 246                   
 247                   bc1b8				
 248 c1b8 ad 10 d0     				LDA SPRITE_MSB
 249 c1bb 09 02        				ORA #$02
 250 c1bd 8d 10 d0     				STA SPRITE_MSB
 251 c1c0 bd e0 cf     				LDA $CFE0,X
 252 c1c3 9d 00 d0     				STA SPRITE0_X,X
 253 c1c6 60           				RTS
 254                   				
 255                   bc1c7				
 256 c1c7 ad 10 d0     				LDA SPRITE_MSB
 257 c1ca 29 fd        				AND #$FD
 258 c1cc 8d 10 d0     				STA SPRITE_MSB
 259 c1cf bd e0 cf     				LDA $CFE0,X
 260 c1d2 9d 00 d0     				STA SPRITE0_X,X
 261 c1d5 60           				RTS
 262                   
 263                   ;c1d6				
 264 c1d6 20 9e c0     				JSR jsr_c09e
 265 c1d9 60           				RTS
 266                   				
 267                   ;$c1da				
 268 c1da 20 b2 c0     				JSR jsr_c0b2
 269 c1dd 60           				RTS
 270                   				
 271                   ;$c1de				
 272 c1de 20 c6 c0     				JSR jsr_c0c6
 273 c1e1 60           				RTS
 274                   ;$c1e2				
 275 c1e2 20 4e c1     				JSR jsr_c14e
 276 c1e5 60           				RTS
 277                   				
 278                   ;$c1e6		
 279 c1e6 20 9e c0     				JSR jsr_c09e
 280 c1e9 20 4e c1     				JSR jsr_c14e
 281 c1ec 60           				RTS
 282                   				
 283                   ;$c1ed				
 284 c1ed 20 b2 c0     				JSR jsr_c0b2
 285 c1f0 20 4e c1     				JSR jsr_c14e
 286 c1f3 60           				RTS
 287                   				
 288                   ;$c1f4				
 289 c1f4 20 b2 c0     				JSR jsr_c0b2
 290 c1f7 20 c6 c0     				JSR jsr_c0c6
 291 c1fa 60           				RTS
 292                   				
 293                   ;$c1fb				
 294 c1fb 20 9e c0     				JSR jsr_c09e
 295 c1fe 20 c6 c0     				JSR jsr_c0c6			
 296 c201 60           				RTS
 297                   				
 298                   ;$c202				
 299 c202 60           				RTS
 300                   
