   1                   .include "for-macros.asm"
   1                   .include "macros.asm"
   1                   .ifndef constants
   2                   .include "const.asm"
   1                   constants=1			
   2                   
   3                   ;
   4                   ; utility routines
   5                   ;
   6                   CLR_SCREEN = $e544
   7                   PLOTK = $e50a			; read/set cursor row(x), col(y) 
   8                   SCROL = $e8ea			; scroll the screen up 1 line 
   9                   DSPP = $ea31			; read the screen & put char in A, color in X 
  10                   MOVE_UP = $a3bf			; move a block of memory up, or move memory  
  11                   						;	from one non-overlapping region to another.
  12                   						;	$5f-$60=source block starting address
  13                   						;	$5a-5b=source block ending address +1
  14                   						;	$58-59=destination's ending address +1
  15                   
  16                   
  17                   ;
  18                   ;	I/O ROUTINES
  19                   ;
  20                   CHROUT = $FFD2			; write byte to default output
  21                   CHRIN = $FFCF			; read byte from default input
  22                   
  23                   SETLFS = $FFBA			; set logical file numbers (open a,x,y)
  24                   SETNAM = $FFBD			; set file name(a=len,x/y=lo/hi for pointer)
  25                   OPEN = $FFC0			; open file (out:c=err, a=1,2,4,5,8 error code)
  26                   CLOSE = $FFC3			; close file (a=fileno)
  27                   CHKIN = $FFC6			; set file as default input(a=filenumber,C=error)
  28                   CHKOUT = $FFC9			; set file as default output(a=filenumber,C=error)
  29                   CLRCHN = $FFCC			; close default input/output files
  30                   LOAD = $FFD5
  31                   SAVE = $FFD8
  32                   GETIN = $FFE4			; read byte from default input (diff with CHRIN?)
  33                   CLALL = $FFE7			; clear file table & call CLRCHN
  34                   READST = $ffb7			; read STatus, leaves it in A
  35                   STATUS = $90			; ST for serial devices.						
  36                   						;	For serial devices:						
  37                   						;		bit 0:timeout (write)
  38                   						;		bit 1:timeout (read)
  39                   						;		bit 6:EOF
  40                   						;		bit 7:device not present 						
  41                   
  42                   STROUT = $ab1e			; print zt string,addr in A/Y
  43                   LINPRT = $BDCD			; print UNSIGNED int in A/X 
  44                   
  45                   PRTSPC = $ab4d			; print a space character
  46                   CRDO = $aad7			; print a CR character, followed by LF
  47                   						;	if channel > 128
  48                   						
  49                   STOP = $ffe1			; check for STOP key. If pressed, 
  50                   						; 	set Z (BEQ), call CLRCHN, print "break".
  51                   FTXTPTR = $7a			; pointer into (usually BASIC) text						
  52                   
  53                   ;
  54                   ;	FAC MATH
  55                   ;
  56                   MOVFA = $bbfc			; copy FAC2 to FAC1
  57                   						
  58                   FAC1 = $61				; $61:exponent (power of 2). 128 or greater means 
  59                   						;	negative exponent
  60                   						; $62-65:mantissa. Also, $62-63 hold result of
  61                   						;	FAC1-to-int conversions
  62                   						; $66:sign. 0=positive, $ff=negative
  63                   						
  64                   FAC2 = $69				; same structure as FAC1
  65                   
  66                   
  67                   AADD = $bd7e			; add A to FAC1
  68                   
  69                   ADDH = $b849			; add 0.5 to FAC1 for rounding
  70                   FSUBT = $b853			; FAC1=FAC2 - FAC1
  71                   FADDT = $b86f			; FAC1=FAC@ + FAC1
  72                   NEGFAC = $b947			; FAC1=negative (2's complement) of FAC1
  73                   FMULTT = $ba30			; FAC1=FAC1 * FAC2
  74                   FDIVT = $bb14			; FAC1=FAC2 / FAC1
  75                   ROUND = $bc2b			; FAC1 = ROUND(FAC1)
  76                   SIGN = $bc2b			; A=(0 if FAC1=0, 1 if FAC1>0, $FF(-1) otherwise)
  77                   						
  78                   FOUTIM = $be68			; convert TI to ASCII string at $100 
  79                   SQR = $bf71				; FAC1=SQR(FAC1) 
  80                   FPWRT = $bf78			; FAC1=FAC2^FAC1 
  81                   NEGOP = $bfb4			; FAC1 = NOT(FAC1) 
  82                   EXP = $bfed				; FAC1=e^EXP1 
  83                   RND = $e097				; FAC1=RND(FAC1), using BASIC's RND() logic 
  84                   COS = $e264				; FAC1=COS(FAC1) 
  85                   SIN = $e26b				; FAC1=SIN(FAC1) 
  86                   TAN = $e2b4				; FAC1=TAN(FAC1) 
  87                   ATN = $e30e				; FAC1=ATAN(FAC1) 
  88                   EVAL = $ae83			; evaluate an arithmetic term from ASCII  
  89                   						;	to a floating point value.   
  90                   
  91                   ;
  92                   ;	FAC CONVERSION ROUTINES
  93                   ;
  94                   PETSCII_TO_FAC1=$bcf3	; convert a PETSCII string containing 
  95                   						; 	a FP constant, to FAC1. before calling,  
  96                   						; 	store the address of the string in $7a/7b, 
  97                   						; 	then JSR $79.
  98                   						
  99                   STRVAL = $b7b5			; convert PETSCII-string to FAC1. Expects 
 100                   						;   string-address in $22/$23 and 
 101                   						;	length of string in accumulator.
 102                   						
 103                   GIVAYF = $b391			; convert signed int in Y/A to FAC1; range -32768 to 32767
 104                   FACINX = $B1AA			; convert FAC1 to 2-byte signed int in A/Y
 105                   FIN = $bfc3				; convert string (pointed to by TXTPTR) 
 106                   						;	to float in FAC1
 107                   FOUT = $bddd			; convert FAC1 to ASCII string, starting at $100
 108                   						; 	and ending with a 0 term. On exit, A/Y holds
 109                   						; 	start address, so STROUT can be called.
 110                   A_TO_FAC1 = $bc3c		; convert unsigned 8-bit int in A to FAC1						
 111                   SNGET = $b3a2  			; convert unsigned 8-bit int in Y to FAC1 
 112                   QINT = $bc9b			; convert FAC1 into 4-byte signed int from $62-65 
 113                   GETADR = $b7f7			; convert FAC1 to a 16-bit int, in $14/$15						
 114                    
 115                    
 116                   ;
 117                   ; interrupt vectors
 118                   ;
 119                   CVINV = $314			; point to IRQ handler, normally $ea31.
 120                   						;	NOTE: A,X,Y are saved on the stack before calling,
 121                   						;		but they are NOT automatically restored
 122                   						
 123                   CBINV = $316			; BRK interrupt handler. Normally $fe66.  
 124                   NMINV = $318			; NMI handler, normally $fe47.  
 125                   						;	NOTE: to disable RS/RESTORE, store a 0 in $318.
 126                   						
 127                   
 128                   						  						 
 129                   
 130                   ;
 131                   ; passing data between basic and ml
 132                   ;
 133                   
 134                   
 135                   A_STORAGE = $30c		; the registers are read from these 
 136                   X_STORAGE = $30d 		;	locations before running a SYS routine,
 137                   Y_STORAGE = $30e 		; 	and the results are stored back into 
 138                   P_STORAGE = $30f 		;	them after the RTS. doesn't apply to USR.
 139                   
 140                   USERADD = $311			; the 16-bit address of a USR routine can be 
 141                   						; 	put into this vector. for example:
 142                   						;		x=usr(17) 								
 143                   						;	...puts the value of 17 in FAC1, calls
 144                   						; 	the routine in $311-312, and assigns the
 145                   						;	value of FAC1 upon exiting, to the var x.
 146                   ;
 147                   ; other basic stuff
 148                   ;
 149                   CHRGET = $73			; reads the next character for processing by basic.
 150                   						;	sets P to indicate what kind of char,  
 151                   						; 	and returns the char in A. C=0-9,Z=end of stmt.
 152                   						
 153                   CHRGOT = $79			; does the same thing, but doesn't increment the						
 154                   						;	char pointer.						
 155                   												
 156                   VERCK = $A				; flag:0=LOAD,1=VERIFY												
 157                   VALTYP = $D				; flag:$FF=string,0=numeric							
 158                   INTFLG = $E				; flag:$80=int,0=fp												
 159                   INPFLG = $11			; flag:0=INPUT,$40=GET,$98=READ												
 160                   CHANNL = $13			; current logical file number (not dev#)												
 161                   TXTTAB = $2b			; beginning of BASIC text, normally $801 
 162                   MEMSIZ = $37			; end of BASIC-available memory 
 163                   CURLIN = $39			; current BASIC line#. $ff in $40 means immediate mode 
 164                   VARPNT = $47			; descriptor of current BASIC variable value 
 165                   OPMASK = $4D			; comparison operation flag: 1=<,2=> 
 166                   DSCPNT = $50			; $50-51 point to current string descriptor, 
 167                   						; 	$52 holds string length
 168                   						
 169                   ARISGN = $6f			; result of comparison between FAC1,FAC2						
 170                   						;	0=like signs, $ff=unlike signs						
 171                   
 172                   STKEY = $91				; value of the last row of the keybd when last scanned. 												 
 173                   						;	$ff=none,$fe=1,$fd=<-,$fb=CTRL,$ef=SPACE,
 174                   						;	$df=Commodore,$bf=Q,$7f=STOP.
 175                   						;	NOTE: this means that you can do this:
 176                   						;		LDA STKEY
 177                   						;		BPL handle_stop
 178                   						
 179                   VERCK2 = $93				; flag for load routine: 0=load/1=verify												
 180                   DFLTN = $99				; current default input device
 181                   DFLTO = $9A				; current default output device
 182                   TIME = $A0				; software jiffy clock, from $a0-a2. 
 183                   						;	24-bit count of jiffies (60/sec) since start.
 184                   						;	resets every 24 hours.
 185                   
 186                   FNLEN = $b7				; size of current filename						
 187                   LA = $b8				; current logical file number(for a different						
 188                   						;	purpose then $13)						
 189                   SA = $b9				; current secondary address												
 190                   FA = $ba				; current device number												
 191                   FNADR = $BB				; 2-byte pointer to filename												
 192                   LSTX = $c5				; matrix coordinate of *last* keypress; 64=none												
 193                   NDX = $c6				; # of characters in keyboard buffer												
 194                   RVS = $c7				; flag: print reverse characters? 0=no												
 195                   						;	NOTE: you can poke 0 here to cancel reverse mode												
 196                   SFDX = $cb				; matrix coords of *current* keypress; 64=none
 197                   BLNSW = $cc				; cursor blink enable:0=flash
 198                   GDBLN = $ce				; screen code of char under cursor
 199                   PNTR = $d3				; cursor column on current line
 200                   QTSW = $d4				; editor in quote mode? 0=no
 201                   TBLx = $d6				; current cursor physical line #
 202                   INSRT = $d8				; insert mode? >0 is # of inserts
 203                   USER = $f3				; 2-byte pointer to current screen color location
 204                   
 205                   COLOR = $286			; current foreground color for text
 206                   GDCOL = $287			; color of character under cursor
 207                   HIBASE = $288			; page of screen memory; normally contains 4(*256=1024)
 208                   						;	NOTE: $d018/$dd00 change ths *display*
 209                   						;	screen location - the one that shown onscreen.
 210                   						; 	this one is the memory written into by CHROUT,etc.
 211                   						
 212                   XMAX	= $289			; max keyvoard buffer size; should be <=10						
 213                   RPTFLAG = $28a			; flag: which keys should repeat?						
 214                   						;	0=normal,$80=all,$40=none						
 215                   												
 216                   SHFLAG = $653			; flag: modifier keys currently pressed?											
 217                   						;	bits: 1=SHIFT,2=Commodore,4=CTRL											
 218                   																	
 219                   MODE = $291				; flag: enable changing char sets with SHIFT/C= ?																	
 220                   						;	$80=disabled, 0=enabled																	
 221                   																							
 222                   AUTODN = $292			; flag: scroll screen on col 40/last line?																							
 223                   						;	0=yes; otherwise=no																							
 224                   																													
 225                   																													
 226                   																		 
 227                   BUF = $200				; BASIC line editor input buffer 
 228                    
 229                    												
 230                   ;
 231                   ; PETSCII
 232                   ;
 233                   SPC = $20
 234                   CR = $0d
 235                   RVS_ON = $12 
 236                   RVS_OFF = $92 
 237                   CLR = $93 
 238                   BLACK = $90
 239                   WHITE = $05
 240                   RED = $1c
 241                   GREEN = $1e
 242                   BLUE = $1f
 243                   ORANGE = $81
 244                   BROWN = $95
 245                   PURPLE = $9c
 246                   YELLOW = $9e
 247                   CYAN = $9f
 248                   LT_RED = $96
 249                   DK_GRAY = $97
 250                   GRAY = $98
 251                   LT_GRAY = $9b
 252                   LT_GREEN = $99
 253                   LT_BLUE = $9a
 254                   HOME = $13
 255                   DEL = $14
 256                   UP = $91
 257                   DOWN = $11
 258                   LEFT = $9d
 259                   RIGHT = $1d
 260                   SHIFT_ON = $09
 261                   SHIFT_OFF = $08
 262                   MODE_TEXT = $0e
 263                   MODE_GRAPH = $8e
 264                   F1 = $85
 265                   F2 = $86
 266                   F3 = $87
 267                   F4 = $88
 268                   F5 = $89
 269                   F6 = $8a
 270                   F7 = $8b
 271                   F8 = $8c 
 272                   DBL_QUOTE = $22 
 273                   SNGL_QUOTE = $27 
 274                   GRAPH_SLASH = $6e 
 275                   GRAPH_BACKSLASH = $6d 
 276                   PIPE = $7d 
 277                   DASH = $60 
 278                   
 279                   ;			
 280                   ; keyboard constants			
 281                   ;			
 282                   SHIFT_KEYS=$028d
 283                   KEY_SHIFT=%00000001
 284                   KEY_COMM=%000000010
 285                   KEY_CTRL=%00000100
 286                   
 287                   ;
 288                   ; zero page locations
 289                   ;
 290                   ; used by tape routines
 291                   ;
 292                   TSERVO = $92
 293                   TEOB = $96
 294                   TEMPXY = $97
 295                   TPARIT = $9b
 296                   TBYTFL = $9c
 297                   HDRTYP = $9e
 298                   PTR1 = $9e
 299                   PTR2 = $9f
 300                   TSFCNT = $a3
 301                   TBTCNT = $a4
 302                   CNTDN = $A5
 303                   BUFPNT = $a6
 304                   PASNUM = $a7
 305                   RIDATA = $aa
 306                   TCKS = $ab
 307                   CMP00 = $b0
 308                   CMPB01 = $b1
 309                   TAPE10 = $b2
 310                   TAPE11 = $b3
 311                   ;
 312                   ; used by rs-232
 313                   RIBUF0 = $f7
 314                   RIBUF1 = $f8
 315                   ROBUF0 = $f9
 316                   ROBUF1 = $fa
 317                   ;
 318                   ; unused
 319                   ;
 320                   MISC_PTR0 = $fb
 321                   MISC_PTR1 = $fc 
 322                   
 323                   ;
 324                   ; I/O Registers
 325                   ;
 326                   SPRITE0_X = $d000
 327                   SPRITE0_Y = $d001
 328                   SPRITE1_X = $d002
 329                   SPRITE1_Y = $d003
 330                   SPRITE2_X = $d004
 331                   SPRITE2_Y = $d005
 332                   SPRITE3_X = $d006
 333                   SPRITE3_Y = $d007
 334                   SPRITE4_X = $d008
 335                   SPRITE4_Y = $d009
 336                   SPRITE5_X = $d00a
 337                   SPRITE5_Y = $d00b
 338                   SPRITE6_X = $d00c
 339                   SPRITE6_Y = $d00d
 340                   SPRITE7_X = $d00e
 341                   SPRITE7_Y = $d00f
 342                   
 343                   SPRITE_MSB = $d010	; sprite 0-7 MSB of x coord
 344                   SCREEN_REG1= $d011	; bits 0-2:vertical raster roll
 345                   					; bit 3: screenm height (24/25 rows)
 346                   					; bit 4: screen off/on
 347                   					; bit 5: text/bitmap screen
 348                   					; bit 6: extended background mode
 349                   					; bit 7: 	read: current raster line
 350                   					;			write: line to generate IRQ at
 351                   					
 352                   RASTER_LINE = $d012 ; read: current raster line
 353                   LIGHTPEN_X = $d013
 354                   LIGHTPEN_Y = $d014
 355                   SPRITE_EN = $d015		; enable/disable bits for sprites 0-7
 356                   
 357                   SCREEN_CTRL = $d016	; 	bits 0-2:horiz raster scroll	
 358                   					;	bit 3: screen width - 38/40 cols	
 359                   					;	bit 4: multicolor mode	
 360                   						
 361                   SPRITE_2X_HT = $d017
 362                   MEM_SETUP = $d018	;	bits 1-3: in text mode, pointer to
 363                   					;		character memory
 364                   					; 	bits 4-7: pointer to screen memory
 365                   					
 366                   SPRITE_PRI = $d01b 	;	bits determine whether sprite x drawn  
 367                   					;		in front of/behind background
 368                   					
 369                   SPRITE_MULTI = $d01a ; sprites 0-7 multicolor on/off 
 370                   SPRITE_2X_WD = $d01d					
 371                   SPR2SPR_COLL = $d01e ; 	read: sprites have collided,					
 372                   					;	write: detect sprite-sprite collisions					
 373                   										
 374                   BORDER_COLOR = $d020 ; bits 0-3 										
 375                   BACKG_COLOR = $d021	; bits 0-3				
 376                   BKG_MULTI_CLR1 = $d022			
 377                   BKG_MULTI_CLR2 = $d023			
 378                   BKG_MULTI_CLR3 = $d024			
 379                   SPR_MULTI_CLR1 = $d025			
 380                   SPR_MULTI_CLR2 = $d026			
 381                   			
 382                   SPRITE0_COLOR = $d027 ; bits 0-3						
 383                   SPRITE1_COLOR = $d028 ; bits 0-3						
 384                   SPRITE2_COLOR = $d029 ; bits 0-3						
 385                   SPRITE3_COLOR = $d02a ; bits 0-3						
 386                   SPRITE4_COLOR = $d02b ; bits 0-3						
 387                   SPRITE5_COLOR = $d02c ; bits 0-3						
 388                   SPRITE6_COLOR = $d02d ; bits 0-3						
 389                   SPRITE7_COLOR = $d02e ; bits 0-3						
 390                   						
 391                   PROCESSOR_DDR = $0	; bits 0-7: set read/write for bit x 
 392                   					;	of processor port					
 393                   										
 394                   PROCESSOR_PORT = $1	; 	bit 0: RAM/ROM at $a000-bfff										
 395                   					;	bit 1: RAM/ROM at $e000-ffff										
 396                   					;	bit 2: RAM/IO ports at $d000-dfff										
 397                   					;	bits 3-5: datasette										
 398                   															
 399                   PRA  =  $dc00			; CIA#1 (Port Register A)
 400                   DDRA =  $dc02			; CIA#1 (Data Direction Register A)
 401                   
 402                   PRB  =  $dc01			; CIA#1 (Port Register B)
 403                   DDRB =  $dc03			; CIA#1 (Data Direction Register B)
 404                   
 405                   SCREEN_RAM = $400
 406                   COLOR_RAM = $d800
 407                   															  					
 408                   
   3                   .endif
   4                   
   5                   macros=1
   6                   
   7                   
   8                   push_axy	.macro
   9                   			pha
  10                   			txa
  11                   			pha
  12                   			tya
  13                   			pha
  14                   			.endm
  15                   
  16                   pull_axy	.macro						
  17                   			pla
  18                   			tay
  19                   			pla
  20                   			tax
  21                   			pla
  22                   			.endm			
  23                   ;
  24                   ;	"~" character prints as CR(13)
  25                   ;
  26                   print_str	.macro
  27                   			
  28                   			pha
  29                   			txa
  30                   			pha
  31                   			
  32                   			#print_str_addr rtxt
  33                   			
  34                   exit
  35                   			jmp end_text		
  36                   						
  37                   rtxt			.null "@1"
  38                   
  39                   end_text							
  40                   			pla						
  41                   			tax						
  42                   			pla						
  43                   									
  44                   			.endm
  45                   
  46                   print_str_addr .macro			
  47                   			ldx #0
  48                   			
  49                   loop			
  50                   			lda \1,x
  51                   			beq exit
  52                   			
  53                   			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54                   			bne print
  55                   			
  56                   			lda #CR
  57                   			
  58                   print			
  59                   			jsr CHROUT			
  60                   			inx			
  61                   			bne loop			
  62                   			.endm			
  63                   			
  64                   ;print_str_cr .segment			
  65                   ;			#print_str "@1"			
  66                   ;			#print_char 13			
  67                   ;			.endm			
  68                   						
  69                   
  70                   print_int	.macro
  71                   			pha
  72                   			tya
  73                   			pha
  74                   			
  75                   			lda #>\1
  76                   			ldy #<\1
  77                   			;jsr LINPRT
  78                   			#print_ay			
  79                   			
  80                   			pla
  81                   			tay
  82                   			pla
  83                   			.endm
  84                   
  85                   print_int_var .macro
  86                   			pha
  87                   			tya
  88                   			pha
  89                   			
  90                   			lda \1+1
  91                   			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
  94                   			
  95                   			pla
  96                   			tay
  97                   			pla
  98                   			.endm
  99                   
 100                   ; loads a,y with the value of the int pointed to 
 101                   ;	by 16-bit ptr \1
 102                   get_ptr_int	.macro
 103                   			
 104                   			ldy #0
 105                   			lda (\1),y
 106                   			
 107                   			pha
 108                   			iny
 109                   			lda (\1),y
 110                   			
 111                   			tax
 112                   			pla
 113                   			tay
 114                   			txa
 115                   
 116                   			.endm
 117                   ;
 118                   ; print a 16-bit int referenced by the
 119                   ;	zero-page 16-bit pointer starting at \1
 120                   ;
 121                   print_int_ptr .macro
 122                   			#push_axy			
 123                   			
 124                   			#get_ptr_int \1			
 125                   
 126                   			#print_ay
 127                   			
 128                   			#pull_axy
 129                   			.endm
 130                   
 131                   print_char_ptr .macro			
 132                   			#push_axy			
 133                   						
 134                   			ldy #0
 135                   			lda (\1),y						
 136                   									
 137                   			jsr CHROUT			
 138                   						
 139                   			#pull_axy			
 140                   			.endm			
 141                   						
 142                   ;
 143                   ; print a zt string referenced by the zero-page 
 144                   ;	16-bit pointer starting at \1
 145                   ;
 146                   print_str_ptr .macro
 147                   			#push_axy			
 148                   
 149                   			ldy #0
 150                   			
 151                   loop			
 152                   			lda (\1),y
 153                   			beq exit
 154                   			
 155                   			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
 156                   			bne print
 157                   			
 158                   			lda #CR
 159                   			
 160                   print			
 161                   			jsr CHROUT			
 162                   			iny			
 163                   			bne loop			
 164                   
 165                   ;finished						
 166                   ;			#pull_axy
 167                   ;			jmp exit
 168                   ;			
 169                   ;temp_a		.byte 00			
 170                   ;temp_y		.byte 00			
 171                   
 172                   exit		
 173                   			#pull_axy
 174                   			.endm
 175                   
 176                   ;
 177                   ;	
 178                   ;
 179                   print_ay	.macro
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183                   			jsr GIVAYF
 184                   			jsr FOUT
 185                   			jsr STROUT
 186                   			
 187                   			pull_axy
 188                   			.endm
 189                   			
 190                   
 191                   print_char	.macro
 192                   			pha	
 193                   				
 194                   			lda #\1
 195                   			jsr CHROUT
 196                   			
 197                   			pla
 198                   			.endm
 199                   			
 200                   print_spc	.macro			
 201                   			#print_char SPC			
 202                   			.endm			
 203                   						
 204                   print_cr	.macro						
 205                   			#print_char CR						
 206                   			.endm						
 207                   															
 208                   			
 209                   print_a		.macro
 210                   			
 211                   			sta temp
 212                   			txa
 213                   			pha
 214                   			
 215                   			lda temp
 216                   			#print_a_bare
 217                   			
 218                   			;jsr A_TO_FAC1
 219                   			;jsr FOUT
 220                   			;jsr STROUT
 221                   ;			pha
 222                   ;			tya
 223                   ;			pha
 224                   ;			
 225                   ;			lda temp
 226                   ;			ldy #0
 227                   ;			#print_ay
 228                   ;			
 229                   ;			pla
 230                   ;			tay
 231                   ;			pla
 232                   			
 233                   			pla
 234                   			tax
 235                   			lda temp	
 236                   			jmp exit	
 237                   				
 238                   temp		.byte 00				
 239                   
 240                   exit				
 241                   			.endm
 242                   
 243                   print_a_bare .macro			
 244                   			tax			
 245                   			lda #0
 246                   			
 247                   			jsr LINPRT
 248                   			
 249                   			.endm
 250                   			
 251                   			
 252                   print_byte	.macro
 253                   			pha
 254                   			txa
 255                   			pha
 256                   
 257                   			lda #\1
 258                   			
 259                   			#print_a_bare
 260                   			
 261                   			pla
 262                   			tax
 263                   			pla
 264                   			.endm
 265                   			
 266                   print_ptr	.macro
 267                   			
 268                   			pha
 269                   			tya
 270                   			pha
 271                   			
 272                   			lda \1+1
 273                   			ldy \1+2
 274                   			jsr LINPRT
 275                   			
 276                   			pla
 277                   			tay
 278                   			pla
 279                   			.endm
 280                   			
 281                   ;			
 282                   ;  increment a 16-bit value 
 283                   ; 			
 284                   inc16		.macro					
 285                   			;#print_str "inc16"					
 286                   								
 287                   ;			pha					
 288                   ;								
 289                   ;			clc
 290                   ;			lda \1					
 291                   ;			#print_str "inc16:a="					
 292                   ;			#print_a					
 293                   ;			#print_char 13					
 294                   ;			adc #1					
 295                   ;			#print_str "inc16:after inc, a="				
 296                   ;			#print_a				
 297                   ;			#print_char 13				
 298                   ;							
 299                   ;			sta \1					
 300                   ;			lda \2					
 301                   ;			adc #0					
 302                   ;			sta \2					
 303                   ;								
 304                   ;			pla								
 305                   
 306                   	label1											
 307                   	label2											
 308                   												
 309                   			.ifdef DEBUG_MACROS								
 310                   				#print_str "inc16:before="								
 311                   				#print_int \1								
 312                   				#print_char CR								
 313                   			.endif								
 314                   											
 315                   			inc \1					
 316                   			bne done					
 317                   								
 318                   			inc \1+1					
 319                   								
 320                   								
 321                   done								
 322                   			.ifdef DEBUG_MACROS			
 323                   				#print_str "inc16:after="			
 324                   				#print_int \1			
 325                   				#print_char CR			
 326                   			.endif			
 327                   						
 328                   			.endm								
 329                   
 330                   ;											
 331                   ; store a 16-bit constant \2 in location \1											
 332                   ;	NOTE: does not save contents of A!											
 333                   ;											
 334                   store16		.macro											
 335                   														
 336                   			lda #<\1											
 337                   			sta \2											
 338                   														
 339                   			lda #>\1											
 340                   			sta \2+1											
 341                   														
 342                   			.endm											
 343                   
 344                   ;											
 345                   ; store the value of 16-bit var \2 in location \1											
 346                   ;	NOTE: does not save contents of A!											
 347                   ;											
 348                   store16var	.macro											
 349                   														
 350                   			lda \1											
 351                   			sta \2											
 352                   														
 353                   			lda \1+1											
 354                   			sta \2+1											
 355                   														
 356                   			.endm											
 357                   														
 358                   ;											
 359                   ; compare two 16-bit pointers.											
 360                   ;	OUT: A=0 if equal, 1 otherwise 											
 361                   ;											
 362                   cmp16vars	.macro						
 363                   			.ifdef DEBUG_MACROS						
 364                   				#print_str "cmp16vars:/1="						
 365                   				#print_int_var \1						
 366                   				#print_str " /2="						
 367                   				#print_int_var \2						
 368                   				#print_char SPC						
 369                   			.endif						
 370                   									
 371                   			lda \1						
 372                   			cmp \2										
 373                   			bne not_equal					
 374                   								
 375                   			lda \1+1					
 376                   			cmp \2+1					
 377                   			bne not_equal					
 378                   	equal								
 379                   			.ifdef DEBUG_MACROS					
 380                   				#print_str "EQUAL!"					
 381                   			.endif					
 382                   			lda #0								
 383                   			beq exit	;always taken							
 384                   										
 385                   	not_equal										
 386                   			lda #1										
 387                   								
 388                   exit																
 389                   			.ifdef DEBUG_MACROS															
 390                   				#print_char CR															
 391                   			.endif															
 392                   			.endm						
 393                   
 394                   									
 395                   ;									
 396                   ; compare a 16-bit var to a constant									
 397                   ;	OUT: A=0 if equal, 1 otherwise 											
 398                   ;									
 399                   cmp16const	.macro						
 400                   			.ifdef DEBUG_MACROS						
 401                   				#print_str "cmp16const:/1="						
 402                   				#print_int \1						
 403                   				#print_str " /2="						
 404                   				#print_int \2						
 405                   				#print_char SPC						
 406                   			.endif						
 407                   																		
 408                   			lda \1						
 409                   			cmp #<\2					
 410                   			bne not_equal					
 411                   								
 412                   			lda \1+1					
 413                   			cmp #>\2					
 414                   			bne not_equal					
 415                   								
 416                   equal								
 417                   			.ifdef DEBUG_MACROS					
 418                   				#print_str "EQUAL!"					
 419                   			.endif					
 420                   			lda #0					
 421                   			beq exit	; always taken					
 422                   								
 423                   not_equal								
 424                   			.ifdef DEBUG_MACROS					
 425                   				#print_str "NOT EQUAL!"					
 426                   			.endif					
 427                   			lda #1								
 428                   								
 429                   exit																
 430                   			.ifdef DEBUG_MACROS															
 431                   				#print_char CR															
 432                   			.endif															
 433                   			.endm						
 434                   
 435                   ;									
 436                   ; 16-bit ints: \1 = \1+\2						
 437                   ;									
 438                   add16		.macro									
 439                   			clc									
 440                   												
 441                   			lda \1									
 442                   			adc \2									
 443                   			sta \1									
 444                   												
 445                   			lda \1+1
 446                   			adc \2+1
 447                   			sta \1+1
 448                   			
 449                   			clc
 450                   			.endm
 451                   			
 452                   			 									
 453                   
   2                   
   3                   ;
   4                   ; FOR..NEXT macros. Syntax is:
   5                   ;	#FOR <start>,<end>,<increment>
   6                   ;		<line1>
   7                   ;		<line2>
   8                   ;	#NEXT
   9                   ;
  10                   ;	NOTES:
  11                   ;		-an increment of 0 means an infinite loop
  12                   ;		-negative increments are possible, using
  13                   ;			2's complement arithmetic (e.g. 
  14                   ;			-5=($FFFF-5) = 65536-5 = 65531/$FFFB ), 
  15                   ;			so the line would be: FOR 20,10,$FFFB 
  16                   ;		-if the increment is not 0, FOR won't loop
  17                   ;			forever, but will stop after $FFFF loops.
  18                   ;			e.g. FOR 20,10,1 runs 65535 times
  19                   ;		-FOR loops can be interrupted via RUN/STOP
  20                   ;		-you can next FOR loops, more or less
  21                   ;			indefnitely. however, the "for_index"
  22                   ;			od the inner loop shadows 
  23                   ;
  24                   ;	BUGS:
  25                   ;		-the index must hit the limit EXACTLY.
  26                   ;			e.g. FOR 10,20,3 runs $FFFF times
  27                   ;
  28                   
  29                   FOR					.segment
  30                   					.block					
  31                   FOR_init			
  32                   					#store16 \1,for_index
  33                   					#store16 \2,for_limit
  34                   					#store16 \3,for_inc			
  35                   								
  36                   					.ifdef DEBUG_MACROS			
  37                   						#print_int_var for_index			
  38                   						#print_spc			
  39                   						#print_int_var for_limit			
  40                   						#print_spc			
  41                   						#print_int_var for_inc			
  42                   						#print_cr			
  43                   					.endif			
  44                   								
  45                   FOR_loop					
  46                   					.endm
  47                   					
  48                   NEXT				.segment
  49                   					pha
  50                   					
  51                   					jsr STOP	; RUN/STOP pressed?
  52                   					bne NEXT_compare
  53                   					jmp FOR_exit
  54                   
  55                   NEXT_compare
  56                   					#cmp16vars for_index,for_limit
  57                   					beq FOR_exit
  58                   					 					
  59                   					pla
  60                   					
  61                   					#add16 for_index,for_inc 
  62                   					
  63                   					jmp FOR_loop
  64                   					
  65                   for_index			.word 00
  66                   for_limit			.word 00
  67                   for_inc				.word 00
  68                   
  69                   FOR_exit
  70                   ; we didn't get a chance to empty the stack earlier
  71                   					pla				
  72                   
  73                   					.bend
  74                   					.endm
  75                   ;
  76                   ;	Syntax is: FOR1 <varname>,<start-index>,<end-index>
  77                   ;FOR1				.macro
  78                   ;	for_@1	
  79                   ;					.byte <\2, >\2					
  80                   ;
  81                   ;for_start_@1
  82                   ;					.endm
  83                   ;					
  84                   ;NEXT1				.macro					
  85                   ;					#inc16 for_index_@1
  86                   ;					#cmp16const for_@1,\3			
  87                   ;					bcc for_start_@1
  88                   ;					
  89                   ;					.endm
  90                   
  91                   
   2                   
   3                   
   4                   *= $801
   5                   ;
   6                   ; BASIC
   7                   ;
   8                   .block
   9 0801 0b 08 0a 00 
  10 0805 9e           		.byte $9e	; SYS
  11 0806 32 30 36 31  		.null "2061"
     080a 00 
  12 080b 00 00        		s .word 0
  13                   .bend
  14                   					
  15                   					
  16                   					#FOR 1,5,1
  30                   					.block					
  31                   FOR_init			
  32                   					#store16 \1,for_index
 335                   														
 336 080d a9 01        			lda #<\1											
 337 080f 8d 50 09     			sta \2											
 338                   														
 339 0812 a9 00        			lda #>\1											
 340 0814 8d 51 09     			sta \2+1											
 341                   														
  33                   					#store16 \2,for_limit
 335                   														
 336 0817 a9 05        			lda #<\1											
 337 0819 8d 52 09     			sta \2											
 338                   														
 339 081c a9 00        			lda #>\1											
 340 081e 8d 53 09     			sta \2+1											
 341                   														
  34                   					#store16 \3,for_inc			
 335                   														
 336 0821 a9 01        			lda #<\1											
 337 0823 8d 54 09     			sta \2											
 338                   														
 339 0826 a9 00        			lda #>\1											
 340 0828 8d 55 09     			sta \2+1											
 341                   														
  35                   								
  36                   					.ifdef DEBUG_MACROS			
  37                   						#print_int_var for_index			
  38                   						#print_spc			
  39                   						#print_int_var for_limit			
  40                   						#print_spc			
  41                   						#print_int_var for_inc			
  42                   						#print_cr			
  43                   					.endif			
  44                   								
  45                   FOR_loop					
  17                   						
  18                   						#print_str "for_index:"
  27                   			
  28 082b 48           			pha
  29 082c 8a           			txa
  30 082d 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 082e a2 00        			ldx #0
  48                   			
  49                   loop			
  50 0830 bd 44 08     			lda \1,x
  51 0833 f0 0c        			beq exit
  52                   			
  53 0835 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 0837 d0 02        			bne print
  55                   			
  56 0839 a9 0d        			lda #CR
  57                   			
  58                   print			
  59 083b 20 d2 ff     			jsr CHROUT			
  60 083e e8           			inx			
  61 083f d0 ef        			bne loop			
  33                   			
  34                   exit
  35 0841 4c 4f 08     			jmp end_text		
  36                   						
  37 0844 46 4f 52 5f  rtxt			.null "@1"
     0848 49 4e 44 45 
     084c 58 3a 00 
  38                   
  39                   end_text							
  40 084f 68           			pla						
  41 0850 aa           			tax						
  42 0851 68           			pla						
  43                   									
  19                   						#print_int_var for_index
  86 0852 48           			pha
  87 0853 98           			tya
  88 0854 48           			pha
  89                   			
  90 0855 ad 51 09     			lda \1+1
  91 0858 ac 50 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 085b 20 91 b3     			jsr GIVAYF
 184 085e 20 dd bd     			jsr FOUT
 185 0861 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 0864 68           			pla
  96 0865 a8           			tay
  97 0866 68           			pla
  20                   						#print_cr
 205                   			#print_char CR						
 192 0867 48           			pha	
 193                   				
 194 0868 a9 0d        			lda #\1
 195 086a 20 d2 ff     			jsr CHROUT
 196                   			
 197 086d 68           			pla
  21                   						#FOR 10,40,10
  30                   					.block					
  31                   FOR_init			
  32                   					#store16 \1,for_index
 335                   														
 336 086e a9 0a        			lda #<\1											
 337 0870 8d 10 09     			sta \2											
 338                   														
 339 0873 a9 00        			lda #>\1											
 340 0875 8d 11 09     			sta \2+1											
 341                   														
  33                   					#store16 \2,for_limit
 335                   														
 336 0878 a9 28        			lda #<\1											
 337 087a 8d 12 09     			sta \2											
 338                   														
 339 087d a9 00        			lda #>\1											
 340 087f 8d 13 09     			sta \2+1											
 341                   														
  34                   					#store16 \3,for_inc			
 335                   														
 336 0882 a9 0a        			lda #<\1											
 337 0884 8d 14 09     			sta \2											
 338                   														
 339 0887 a9 00        			lda #>\1											
 340 0889 8d 15 09     			sta \2+1											
 341                   														
  35                   								
  36                   					.ifdef DEBUG_MACROS			
  37                   						#print_int_var for_index			
  38                   						#print_spc			
  39                   						#print_int_var for_limit			
  40                   						#print_spc			
  41                   						#print_int_var for_inc			
  42                   						#print_cr			
  43                   					.endif			
  44                   								
  45                   FOR_loop					
  22                   								;#print_char 19 ;TAB
  23                   								#print_str "for_index:"
  27                   			
  28 088c 48           			pha
  29 088d 8a           			txa
  30 088e 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 088f a2 00        			ldx #0
  48                   			
  49                   loop			
  50 0891 bd a5 08     			lda \1,x
  51 0894 f0 0c        			beq exit
  52                   			
  53 0896 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 0898 d0 02        			bne print
  55                   			
  56 089a a9 0d        			lda #CR
  57                   			
  58                   print			
  59 089c 20 d2 ff     			jsr CHROUT			
  60 089f e8           			inx			
  61 08a0 d0 ef        			bne loop			
  33                   			
  34                   exit
  35 08a2 4c b0 08     			jmp end_text		
  36                   						
  37 08a5 46 4f 52 5f  rtxt			.null "@1"
     08a9 49 4e 44 45 
     08ad 58 3a 00 
  38                   
  39                   end_text							
  40 08b0 68           			pla						
  41 08b1 aa           			tax						
  42 08b2 68           			pla						
  43                   									
  24                   								#print_int_var for_index
  86 08b3 48           			pha
  87 08b4 98           			tya
  88 08b5 48           			pha
  89                   			
  90 08b6 ad 11 09     			lda \1+1
  91 08b9 ac 10 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 08bc 20 91 b3     			jsr GIVAYF
 184 08bf 20 dd bd     			jsr FOUT
 185 08c2 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 08c5 68           			pla
  96 08c6 a8           			tay
  97 08c7 68           			pla
  25                   								#print_cr
 205                   			#print_char CR						
 192 08c8 48           			pha	
 193                   				
 194 08c9 a9 0d        			lda #\1
 195 08cb 20 d2 ff     			jsr CHROUT
 196                   			
 197 08ce 68           			pla
  26                   								
  27                   								#inc16 counter
 285                   			;#print_str "inc16"					
 286                   								
 287                   ;			pha					
 288                   ;								
 289                   ;			clc
 290                   ;			lda \1					
 291                   ;			#print_str "inc16:a="					
 292                   ;			#print_a					
 293                   ;			#print_char 13					
 294                   ;			adc #1					
 295                   ;			#print_str "inc16:after inc, a="				
 296                   ;			#print_a				
 297                   ;			#print_char 13				
 298                   ;							
 299                   ;			sta \1					
 300                   ;			lda \2					
 301                   ;			adc #0					
 302                   ;			sta \2					
 303                   ;								
 304                   ;			pla								
 305                   
 306                   	label1											
 307                   	label2											
 308                   												
 309                   			.ifdef DEBUG_MACROS								
 310                   				#print_str "inc16:before="								
 311                   				#print_int \1								
 312                   				#print_char CR								
 313                   			.endif								
 314                   											
 315 08cf ee 99 09     			inc \1					
 316 08d2 d0 03        			bne done					
 317                   								
 318 08d4 ee 9a 09     			inc \1+1					
 319                   								
 320                   								
 321                   done								
 322                   			.ifdef DEBUG_MACROS			
 323                   				#print_str "inc16:after="			
 324                   				#print_int \1			
 325                   				#print_char CR			
 326                   			.endif			
 327                   						
  28                   								  
  29                   						#NEXT
  49 08d7 48           					pha
  50                   					
  51 08d8 20 e1 ff     					jsr STOP	; RUN/STOP pressed?
  52 08db d0 03        					bne NEXT_compare
  53 08dd 4c 16 09     					jmp FOR_exit
  54                   
  55                   NEXT_compare
  56                   					#cmp16vars for_index,for_limit
 363                   			.ifdef DEBUG_MACROS						
 364                   				#print_str "cmp16vars:/1="						
 365                   				#print_int_var \1						
 366                   				#print_str " /2="						
 367                   				#print_int_var \2						
 368                   				#print_char SPC						
 369                   			.endif						
 370                   									
 371 08e0 ad 10 09     			lda \1						
 372 08e3 cd 12 09     			cmp \2										
 373 08e6 d0 0c        			bne not_equal					
 374                   								
 375 08e8 ad 11 09     			lda \1+1					
 376 08eb cd 13 09     			cmp \2+1					
 377 08ee d0 04        			bne not_equal					
 378                   	equal								
 379                   			.ifdef DEBUG_MACROS					
 380                   				#print_str "EQUAL!"					
 381                   			.endif					
 382 08f0 a9 00        			lda #0								
 383 08f2 f0 02        			beq exit	;always taken							
 384                   										
 385                   	not_equal										
 386 08f4 a9 01        			lda #1										
 387                   								
 388                   exit																
 389                   			.ifdef DEBUG_MACROS															
 390                   				#print_char CR															
 391                   			.endif															
  57 08f6 f0 1e        					beq FOR_exit
  58                   					 					
  59 08f8 68           					pla
  60                   					
  61                   					#add16 for_index,for_inc 
 439 08f9 18           			clc									
 440                   												
 441 08fa ad 10 09     			lda \1									
 442 08fd 6d 14 09     			adc \2									
 443 0900 8d 10 09     			sta \1									
 444                   												
 445 0903 ad 11 09     			lda \1+1
 446 0906 6d 15 09     			adc \2+1
 447 0909 8d 11 09     			sta \1+1
 448                   			
 449 090c 18           			clc
  62                   					
  63 090d 4c 8c 08     					jmp FOR_loop
  64                   					
  65 0910 00 00        for_index			.word 00
  66 0912 00 00        for_limit			.word 00
  67 0914 00 00        for_inc				.word 00
  68                   
  69                   FOR_exit
  70                   ; we didn't get a chance to empty the stack earlier
  71 0916 68           					pla				
  72                   
  73                   					.bend
  30                   					#NEXT
  49 0917 48           					pha
  50                   					
  51 0918 20 e1 ff     					jsr STOP	; RUN/STOP pressed?
  52 091b d0 03        					bne NEXT_compare
  53 091d 4c 56 09     					jmp FOR_exit
  54                   
  55                   NEXT_compare
  56                   					#cmp16vars for_index,for_limit
 363                   			.ifdef DEBUG_MACROS						
 364                   				#print_str "cmp16vars:/1="						
 365                   				#print_int_var \1						
 366                   				#print_str " /2="						
 367                   				#print_int_var \2						
 368                   				#print_char SPC						
 369                   			.endif						
 370                   									
 371 0920 ad 50 09     			lda \1						
 372 0923 cd 52 09     			cmp \2										
 373 0926 d0 0c        			bne not_equal					
 374                   								
 375 0928 ad 51 09     			lda \1+1					
 376 092b cd 53 09     			cmp \2+1					
 377 092e d0 04        			bne not_equal					
 378                   	equal								
 379                   			.ifdef DEBUG_MACROS					
 380                   				#print_str "EQUAL!"					
 381                   			.endif					
 382 0930 a9 00        			lda #0								
 383 0932 f0 02        			beq exit	;always taken							
 384                   										
 385                   	not_equal										
 386 0934 a9 01        			lda #1										
 387                   								
 388                   exit																
 389                   			.ifdef DEBUG_MACROS															
 390                   				#print_char CR															
 391                   			.endif															
  57 0936 f0 1e        					beq FOR_exit
  58                   					 					
  59 0938 68           					pla
  60                   					
  61                   					#add16 for_index,for_inc 
 439 0939 18           			clc									
 440                   												
 441 093a ad 50 09     			lda \1									
 442 093d 6d 54 09     			adc \2									
 443 0940 8d 50 09     			sta \1									
 444                   												
 445 0943 ad 51 09     			lda \1+1
 446 0946 6d 55 09     			adc \2+1
 447 0949 8d 51 09     			sta \1+1
 448                   			
 449 094c 18           			clc
  62                   					
  63 094d 4c 2b 08     					jmp FOR_loop
  64                   					
  65 0950 00 00        for_index			.word 00
  66 0952 00 00        for_limit			.word 00
  67 0954 00 00        for_inc				.word 00
  68                   
  69                   FOR_exit
  70                   ; we didn't get a chance to empty the stack earlier
  71 0956 68           					pla				
  72                   
  73                   					.bend
  31                   
  32                   					#print_str "counter:"
  27                   			
  28 0957 48           			pha
  29 0958 8a           			txa
  30 0959 48           			pha
  31                   			
  32                   			#print_str_addr rtxt
  47 095a a2 00        			ldx #0
  48                   			
  49                   loop			
  50 095c bd 70 09     			lda \1,x
  51 095f f0 0c        			beq exit
  52                   			
  53 0961 c9 7e        			cmp #126		;'~'in ASCII, PI-symbol in PETSCII
  54 0963 d0 02        			bne print
  55                   			
  56 0965 a9 0d        			lda #CR
  57                   			
  58                   print			
  59 0967 20 d2 ff     			jsr CHROUT			
  60 096a e8           			inx			
  61 096b d0 ef        			bne loop			
  33                   			
  34                   exit
  35 096d 4c 79 09     			jmp end_text		
  36                   						
  37 0970 43 4f 55 4e  rtxt			.null "@1"
     0974 54 45 52 3a 
     0978 00 
  38                   
  39                   end_text							
  40 0979 68           			pla						
  41 097a aa           			tax						
  42 097b 68           			pla						
  43                   									
  33                   					#print_int_var counter
  86 097c 48           			pha
  87 097d 98           			tya
  88 097e 48           			pha
  89                   			
  90 097f ad 9a 09     			lda \1+1
  91 0982 ac 99 09     			ldy \1
  92                   			;jsr LINPRT
  93                   			#print_ay			
 180                   			push_axy
 181                   			
 182                   			;jsr LINPRT
 183 0985 20 91 b3     			jsr GIVAYF
 184 0988 20 dd bd     			jsr FOUT
 185 098b 20 1e ab     			jsr STROUT
 186                   			
 187                   			pull_axy
  94                   			
  95 098e 68           			pla
  96 098f a8           			tay
  97 0990 68           			pla
  34                   					#print_cr
 205                   			#print_char CR						
 192 0991 48           			pha	
 193                   				
 194 0992 a9 0d        			lda #\1
 195 0994 20 d2 ff     			jsr CHROUT
 196                   			
 197 0997 68           			pla
  35                   					
  36 0998 60           					rts					
  37                   
  38 0999 00 00        counter				.word 0000					
  39                   
