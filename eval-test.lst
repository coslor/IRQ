   1                   				* = $c000
   2                   
   3                   .include "const.asm"				
   1                   constants=1			
   2                   
   3                   
   4                   CLR_SCREEN = $e544
   5                   PLOTK = $e50a			; read/set cursor row(x), col(y) 
   6                   SCROL = $e8ea			; scroll the screen up 1 line 
   7                   DSPP = $ea31			; read the screen & put char in A, color in X 
   8                   
   9                   
  10                   ;
  11                   ;	I/O ROUTINES
  12                   ;
  13                   CHROUT = $FFD2			; write byte to default output
  14                   CHRIN = $FFCF			; read byte from default input
  15                   
  16                   SETLFS = $FFBA			; set logical file numbers (open a,x,y)
  17                   SETNAM = $FFBD			; set file name(a=len,x/y=lo/hi for pointer)
  18                   OPEN = $FFC0			; open file (out:c=err, a=1,2,4,5,8 error code)
  19                   CLOSE = $FFC3			; close file (a=fileno)
  20                   CHKIN = $FFC6			; set file as default input(a=filenumber,C=error)
  21                   CHKOUT = $FFC9			; set file as default output(a=filenumber,C=error)
  22                   CLRCHN = $FFCC			; close default input/output files
  23                   LOAD = $FFD5
  24                   SAVE = $FFD8
  25                   GETIN = $FFE4			; read byte from default input (diff with CHRIN?)
  26                   CLALL = $FFE7			; clear file table & call CLRCHN
  27                   READST = $ffb7			; read STatus, leaves it in A
  28                   STATUS = $90			; ST for serial devices						
  29                   
  30                   STROUT = $ab1e			; print zt string,addr in A/Y
  31                   LINPRT = $BDCD			; print UNSIGNED int in A/X 
  32                   
  33                   PRTSPC = $ab4d			; print a space character
  34                   CRDO = $aad7			; print a CR character, followed by LF
  35                   						;	if channel > 128
  36                   						
  37                   STOP = $ffe1			; check for STOP key. If pressed, 
  38                   						; 	set Z (BEQ), call CLRCHN, print "break".
  39                   FTXTPTR = $7a			; pointer into (usually BASIC) text						
  40                   
  41                   FA = $BA				; last used device number
  42                   ;
  43                   ;	FAC MATH
  44                   ;
  45                   MOVFA = $bbfc			; copy FAC2 to FAC1
  46                   						
  47                   FAC2 = $69
  48                   FAc1 = $66
  49                   
  50                   AADD = $bd7e			; add A to FAC1
  51                   
  52                   ADDH = $b849			; add 0.5 to FAC1 for rounding
  53                   FSUBT = $b853			; FAC1=FAC2 - FAC1
  54                   FADDT = $b86f			; FAC1=FAC@ + FAC1
  55                   COMPLT = $b947			; FAC1= two's complement of FAC1
  56                   FMULTT = $ba30			; FAC1=FAC1 * FAC2
  57                   FDIVT = $bb14			; FAC1=FAC2 / FAC1
  58                   ROUND = $bc2b			; FAC1 = ROUND(FAC1)
  59                   SIGN = $bc2b			; A=(0 if FAC1=0, 1 if FAC1>0, $FF(-1) otherwise)
  60                   						
  61                   FOUTIM = $be68			; convert TI to ASCII string at $100 
  62                   SQR = $bf71				; FAC1=SQR(FAC1) 
  63                   FPWRT = $bf78			; FAC1=FAC2^FAC1 
  64                   NEGOP = $bfb4			; FAC1 = NOT(FAC1) 
  65                   EXP = $bfed				; FAC1=e^EXP1 
  66                   RND = $e097				; FAC1=RND(FAC1), using BASIC's RND() logic 
  67                   COS = $e264				; FAC1=COS(FAC1) 
  68                   SIN = $e26b				; FAC1=SIN(FAC1) 
  69                   TAN = $e2b4				; FAC1=TAN(FAC1) 
  70                   ATN = $e30e				; FAC1=ATAN(FAC1) 
  71                   EVAL = $ae83			; evaluate an arithmetic term from ASCII  
  72                   						;	to a floating point value.   
  73                   
  74                   ;
  75                   ;	FAC CONVERSION ROUTINES
  76                   ;
  77                   PETSCII_TO_FAC1=$bcf3	; convert a PETSCII string containing 
  78                   						; 	a FP constant, to FAC1. before calling,  
  79                   						; 	store the address of the string in $7a/7b, 
  80                   						; 	then JSR $79.
  81                   						
  82                   STRVAL = $b7b5			; Convert PETSCII-string to FAC1. Expects 
  83                   						;   string-address in $22/$23 and 
  84                   						;	length of string in accumulator.
  85                   						
  86                   GIVAYF = $b391			; convert signed int in Y/A to FAC1; range -32768 to 32767
  87                   FACINX = $B1AA			; convert FAC1 to 2-byte signed int in A/Y
  88                   FIN = $bfc3				; convert string (pointed to by TXTPTR) 
  89                   						;	to float in FAC1
  90                   FOUT = $bddd			; convert FAC1 to ASCII string, starting at $100
  91                   						; 	and ending with a 0 term. On exit, A/Y holds
  92                   						; 	start address, so STROUT can be called.
  93                   A_TO_FAC1 = $bc3c		; Convert unsigned 8-bit int in A to FAC1						
  94                   SNGET = $b3a2  			; Convert unsigned 8-bit int in Y to FAC1 
  95                   QINT = $bc9b			; Convert FAC1 into 4-byte signed int from $62-65 
  96                    
  97                    
  98                   ;
  99                   ; interrupt vectors
 100                   ;
 101                   CVINV = $314			; point to IRQ handler, normally $ea31.
 102                   						;	NOTE: A,X,Y are saved on the stack before calling,
 103                   						;		but they are NOT automatically restored
 104                   						
 105                   CBINV = $316			; BRK interrupt handler. Normally $fe66.  
 106                   NMINV = $318			; NMI handler, normally $fe47.  
 107                   						;	NOTE: to disable RS/RESTORE, store a 0 in $318.
 108                   
 109                   						  						 
 110                   
 111                   ;
 112                   ; passing data between basic and ml
 113                   ;
 114                   
 115                   
 116                   A_STORAGE = $30c		; the registers are read from these 
 117                   X_STORAGE = $30d 		;	locations before running a SYS routine,
 118                   Y_STORAGE = $30e 		; 	and the results are stored back into 
 119                   P_STORAGE = $30f 		;	them after the RTS. doesn't apply to USR.
 120                   
 121                   USERADD = $311			; the 16-bit address of a USR routine can be 
 122                   						; 	put into this vector. for example:
 123                   						;		x=usr(17) 								
 124                   						;	...puts the value of 17 in FAC1, calls
 125                   						; 	the routine in $311-312, and assigns the
 126                   						;	value of FAC1 upon exiting, to the var x.
 127                   ;
 128                   ; other basic stuff
 129                   ;
 130                   CHRGET = $73			; reads the next character for processing by basic.
 131                   						;	sets P to indicate what kind of char,  
 132                   						; 	and returns the char in A. C=0-9,Z=end of stmt.
 133                   						
 134                   CHRGOT = $79			; does the same thing, but doesn't increment the						
 135                   						;	char pointer.						
 136                   ;
 137                   ; PETSCII
 138                   ;
 139                   SPC = $20
 140                   CR = $0d
 141                   RVS_ON = $12 
 142                   RVS_OFF = $92 
 143                   CLR = $93 
 144                   BLACK = $90
 145                   WHITE = $05
 146                   RED = $1c
 147                   GREEN = $1e
 148                   BLUE = $1f
 149                   ORANGE = $81
 150                   BROWN = $95
 151                   PURPLE = $9c
 152                   YELLOW = $9e
 153                   CYAN = $9f
 154                   LT_RED = $96
 155                   DK_GRAY = $97
 156                   GRAY = $98
 157                   LT_GRAY = $9b
 158                   LT_GREEN = $99
 159                   LT_BLUE = $9a
 160                   HOME = $13
 161                   DEL = $14
 162                   UP = $91
 163                   DOWN = $11
 164                   LEFT = $9d
 165                   RIGHT = $1d
 166                   SHIFT_ON = $09
 167                   SHIFT_OFF = $08
 168                   MODE_TEXT = $0e
 169                   MODE_GRAPH = $8e
 170                   F1 = $85
 171                   F2 = $86
 172                   F3 = $87
 173                   F4 = $88
 174                   F5 = $89
 175                   F6 = $8a
 176                   F7 = $8b
 177                   F8 = $8c 
 178                   DBL_QUOTE = $22 
 179                   SNGL_QUOTE = $27 
 180                   GRAPH_SLASH = $6e 
 181                   GRAPH_BACKSLASH = $6d 
 182                   PIPE = $7d 
 183                   DASH = $60 
 184                   
 185                   ;			
 186                   ; keyboard constants			
 187                   ;			
 188                   SHIFT_KEYS=$028d
 189                   KEY_SHIFT=%00000001
 190                   KEY_COMM=%000000010
 191                   KEY_CTRL=%00000100
 192                   
 193                   ;
 194                   ; zero page locations
 195                   ;
 196                   ; used by tape routines
 197                   ;
 198                   TSERVO = $92
 199                   TEOB = $96
 200                   TEMPXY = $97
 201                   TPARIT = $9b
 202                   TBYTFL = $9c
 203                   HDRTYP = $9e
 204                   PTR1 = $9e
 205                   PTR2 = $9f
 206                   TSFCNT = $a3
 207                   TBTCNT = $a4
 208                   CNTDN = $A5
 209                   BUFPNT = $a6
 210                   PASNUM = $a7
 211                   RIDATA = $aa
 212                   TCKS = $ab
 213                   CMP00 = $b0
 214                   CMPB01 = $b1
 215                   TAPE10 = $b2
 216                   TAPE11 = $b3
 217                   ;
 218                   ; used by rs-232
 219                   RIBUF0 = $f7
 220                   RIBUF1 = $f8
 221                   ROBUF0 = $f9
 222                   ROBUF1 = $fa
 223                   ;
 224                   ; unused
 225                   ;
 226                   MISC_PTR0 = $fb
 227                   MISC_PTR1 = $fc 
 228                   
 229                   ;
 230                   ; I/O Registers
 231                   ;
 232                   SPRITE0_X = $d000
 233                   SPRITE0_Y = $d001
 234                   SPRITE1_X = $d002
 235                   SPRITE1_Y = $d003
 236                   SPRITE2_X = $d004
 237                   SPRITE2_Y = $d005
 238                   SPRITE3_X = $d006
 239                   SPRITE3_Y = $d007
 240                   SPRITE4_X = $d008
 241                   SPRITE4_Y = $d009
 242                   SPRITE5_X = $d00a
 243                   SPRITE5_Y = $d00b
 244                   SPRITE6_X = $d00c
 245                   SPRITE6_Y = $d00d
 246                   SPRITE7_X = $d00e
 247                   SPRITE7_Y = $d00f
 248                   
 249                   SPRITE_MSB = $d010	; sprite 0-7 MSB of x coord
 250                   SCREEN_REG1= $d011	; bits 0-2:vertical raster roll
 251                   					; bit 3: screenm height (24/25 rows)
 252                   					; bit 4: screen off/on
 253                   					; bit 5: text/bitmap screen
 254                   					; bit 6: extended background mode
 255                   					; bit 7: 	read: current raster line
 256                   					;			write: line to generate IRQ at
 257                   					
 258                   RASTER_LINE = $d012 ; read: current raster line
 259                   LIGHTPEN_X = $d013
 260                   LIGHTPEN_Y = $d014
 261                   SPRITE_EN = $d015		; enable/disable bits for sprites 0-7
 262                   
 263                   SCREEN_CTRL = $d016	; 	bits 0-2:horiz raster scroll	
 264                   					;	bit 3: screen width - 38/40 cols	
 265                   					;	bit 4: multicolor mode	
 266                   						
 267                   SPRITE_2X_HT = $d017
 268                   MEM_SETUP = $d018	;	bits 1-3: in text mode, pointer to
 269                   					;		character memory
 270                   					; 	bits 4-7: pointer to screen memory
 271                   					
 272                   SPRITE_PRI = $d01b 	;	bits determine whether sprite x drawn  
 273                   					;		in front of/behind background
 274                   					
 275                   SPRITE_MULTI = $d01a ; sprites 0-7 multicolor on/off 
 276                   SPRITE_2X_WD = $d01d					
 277                   SPR2SPR_COLL = $d01e ; 	read: sprites have collided,					
 278                   					;	write: detect sprite-sprite collisions					
 279                   										
 280                   BORDER_COLOR = $d020 ; bits 0-3 										
 281                   BACKG_COLOR = $d021	; bits 0-3				
 282                   BKG_MULTI_CLR1 = $d022			
 283                   BKG_MULTI_CLR2 = $d023			
 284                   BKG_MULTI_CLR3 = $d024			
 285                   SPR_MULTI_CLR1 = $d025			
 286                   SPR_MULTI_CLR2 = $d026			
 287                   			
 288                   SPRITE0_COLOR = $d027 ; bits 0-3						
 289                   SPRITE1_COLOR = $d028 ; bits 0-3						
 290                   SPRITE2_COLOR = $d029 ; bits 0-3						
 291                   SPRITE3_COLOR = $d02a ; bits 0-3						
 292                   SPRITE4_COLOR = $d02b ; bits 0-3						
 293                   SPRITE5_COLOR = $d02c ; bits 0-3						
 294                   SPRITE6_COLOR = $d02d ; bits 0-3						
 295                   SPRITE7_COLOR = $d02e ; bits 0-3						
 296                   						
 297                   PROCESSOR_DDR = $0	; bits 0-7: set read/write for bit x 
 298                   					;	of processor port					
 299                   										
 300                   PROCESSOR_PORT = $1	; 	bit 0: RAM/ROM at $a000-bfff										
 301                   					;	bit 1: RAM/ROM at $e000-ffff										
 302                   					;	bit 2: RAM/IO ports at $d000-dfff										
 303                   					;	bits 3-5: datasette										
 304                   															
 305                   PRA  =  $dc00			; CIA#1 (Port Register A)
 306                   DDRA =  $dc02			; CIA#1 (Data Direction Register A)
 307                   
 308                   PRB  =  $dc01			; CIA#1 (Port Register B)
 309                   DDRB =  $dc03			; CIA#1 (Data Direction Register B)
 310                   
 311                   SCREEN_RAM = $400
 312                   COLOR_RAM = $d800
 313                   															  					
 314                   
   4                   				
   5                   start							
   6 c000 20 83 ae     				jsr EVAL		; results now in FAC1								
   7 c003 20 dd bd     				jsr FOUT	
   8 c006 20 1e ab     				jsr STROUT	
   9                   					
  10 c009 60           				rts	
  11                   					
  12                   								
  13                   
